---
title: "Whole Genome Sequencing of <i>Ascochyta rabiei</i> Isolates"
author: "Ido Bar"
date: "18 July 2017"
always_allow_html: yes
output: 
    # md_document:
#      css: "style/style.css"
      # toc: true
      # toc_depth: 3
#      highlight: pygments
#      number_sections: false
    html_document:
      css: "style/style.css"
      toc: true
      toc_float: true
      toc_depth: 3
      highlight: pygments
      number_sections: false
      code_folding: hide
#      keep_md: true
bibliography: style/Fungal_genomes.bib
csl: style/springer-basic-improved-author-date-with-italic-et-al-period.csl
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(list(echo = TRUE, eval=FALSE, message=FALSE))
# load custom functions from github
devtools::source_gist("7f63547158ecdbacf31b54a58af0d1cc", filename = "util.R")
# options(width = 180)
cran_packages <- c("tidyverse", "knitr", "pander", "captioner", "DT", "circlize", "htmltab", "paletteer", "here")
pacman::p_load(char=cran_packages, repos="https://cran.rstudio.com/")
# Connect to Zotero to access references
# biblio <- ReadBib("data/Fungal_genomes.bib") # , "bibtex", "RefManageR"
# Font Format
custom_font="consolas"
fontFmt = function(x,font="consolas"){
  #outputFormat = knitr::opts_knit$get("rmarkdown.pandoc.to")
  #if (outputFormat == 'html')
  formatted_text <- sprintf("<font face='%s'>%s</font>",font,x)
  return(formatted_text)
  #else
  #  x
}
```



```{r captions, include=FALSE, eval=TRUE}
figs <- captioner(prefix="Figure")
tbls <- captioner(prefix="Table")
tbls(name="samples","Ascochyta rabiei isolates used for DNA sequencing.")
# tbls(name="tfam","PLINK's .tfam file format.")
tbls(name="mapping_rates", "Mapping rates of the WGS reads to the Ascochyta rabiei Me14 reference genome.")
tbls(name="mapping_sum", "Mapping statistics for 2017 and 2018 sequencing batches.")
# figs(name="GC_cont", "GC (%) content in trimmed WGS reads.")
figs(name="kmer_peaks", "A. rabiei genome ploidy and size estimation based on k-mer analysis.")
isolate_table <- readxl::read_excel(here("sample_info/A_rabiei_isolate_list_for_wgs.xlsx"), 
                                    sheet = "Sequenced")
sequencing_table <- readxl::read_excel(here("sample_info/A_rabiei_isolate_list_for_wgs.xlsx"), 
                                       sheet = "submission_info") 
sequencing_dict <- set_names(sequencing_table$Isolate, sequencing_table$Submission_id)
samples_table <- isolate_table %>% arrange(desc(Pathogenicity), desc(Collection_Year), Site)

```

# Experimental Design
In 2017, DNA was extracted from 21 strains of _Ascochyta rabiei_ and sent for Whole-Genome-Sequencing (WGS) on an Illumina HiSeq2500, producing 100 bp short paired-end reads (Macrogen, Korea; detailed sequencing report can be found at `Macrogen_report_1702KHP-0164.pdf` file).  
In the following year (2018), DNA from 20 additional *A. rabiei* isolates was extracted and sent for WGS, first to AgriBio, Centre for AgriBioscience, Agriculture Victoria Research ([Dimpy](mailto:sukhjiwan.kaur\@ecodev.vic.gov.au) and [Brittney](mailto:brittney.caruana\@ecodev.vic.gov.au)) on a HiSeq3000, producing 150 bp paired-end reads. Since the library preparation and sequencing was substantially delayed, 18 DNA samples, mostly overlapping with the 20 samples sent for AgriVic, were sent for sequencing at the Australian Genome Research Facility (AGRF, Melbourne) on 4 lanes of a NextSeq500 flowcell, producing 150 bp paried-end reads (run name CAGRF19461).  
Details of the sequenced isolates is provided in (`r tbls(name="samples",display="cite")`).

```{r samples_table, eval=TRUE} 
datatable(as.data.frame(samples_table), caption=tbls("samples")) %>% # , 
          # options = list(dom = 'tf', pageLength = 40)) %>%
  formatStyle('Pathogenicity',
  backgroundColor = styleInterval(0:3, c('limegreen','gold', 'orange', 'orangered', 'firebrick'))
)# pander , justify="left"
```

# Aims
* Identify strain-unique variants to develop detection methods
* Associate aggressiveness with specific variants

# Analysis Pipeline
## General overview:
1. Data pre-processing:
    a. Quality check
    b. Adaptor trimming
    c. Post-trim quality check
2. Mapping reads to a reference genome (keep unmapped)
3. Reads deduplication
4. Variant calling and filtration
5. Variant annotation (including assigining SSR haplotypes)
6. Variant-Pathogenicity association
7. Produce variant statistics and assessment 

## Methods
DNA-Seq data processing, mapping and variant calling were performed on the _Griffith University Gowonda HPC Cluster_ (using Torque scheduler), following the methods specified by @hagiwara_whole-genome_2014 (see details in Appendix 2), @haas_approaches_2011, @hittalmani_novo_2016 and @verma_draft_2016, with modification to use `r fontFmt("FreeBayes")` v1.2.0 [@garrison_haplotype-based_2012] to assign variant probability scores and call variants.  

At the current pipeline, each sequencing batch is processed separately due to slightly different file naming concentions. In future batches, the read files should be renamed following a standard naming conventions (starting from a pair of `Sample_id_FlowCell_R#.fastq.gz` file), which will make it much easier to process all batches with the same script, using parameters to specify batch name, read length, sequencing platform and other potential variables. Detailed methods, including code for running each of the analyses steps are provided in the associated [A_rabiei_WGS_analysis GitHub repository](https://github.com/IdoBar/A_rabiei_WGS_analysis).

### Data pre-processing
Install needed software in a `conda` environment on Gowonda2.
```{bash setup_tools}
# install sambamba (need to fix internet connection to gowonda2 - use patched netcheck in ~/bin)
~/bin/netcheck
conda install -c bioconda sambamba htslib samtools bcftools snpsift snpeff multiqc fastqc dnapi igvtools qualimap bbmap gatk picard bowtie2 samblaster freebayes jellyfish bbmap
conda install -c biobuilds igv
# Clean extra space
conda clean -y --all
# Install pdfx to parse the report and download the files, see https://stackoverflow.com/a/33173484
easy_install -U pdfx
```

#### Adaptor Trimming
Adaptors needed to be removed, as well as very low quality bases/reads, so trimming was performed with BBduk (from BBMap v38.34). See official download page on [SourceForge](https://sourceforge.net/projects/bbmap/), [user guide](http://jgi.doe.gov/data-and-tools/bbtools/bb-tools-user-guide/bbduk-guide/) and [SEQanswers thread](http://seqanswers.com/forums/showthread.php?t=42776).  

### Mapping to the reference genome (using Bowtie2)
The trimmed reads were mapped to the _A. rabiei_ reference genome, strain Me14, NCBI Accession [GCA_004011695.1](https://www.ncbi.nlm.nih.gov/assembly/GCA_004011695.1/) [@shahReferenceGenomeAssembly2020] using `r fontFmt("Bowtie2")` v2.3.4.3 with the `--very-sensitive` option in `--end-to-end` (global) mode [@langmeadFastGappedreadAlignment2012]. The resulting SAM files were processed to mark duplicates with `r fontFmt("SAMBLASTER")` v0.1.24 [@faust_samblaster:_2014] and converted into coordinate-sorted, indexed BAM files with read groups using [Picard v2.18.22](https://broadinstitute.github.io/picard/). Mapping statistics (rate, quality and coverage) were evaluated with `r fontFmt("Qualimap 2")` v.2.2.2-dev [@okonechnikov_qualimap_2016].       
Raw files quality after adaptor trimming was assessed with `r fontFmt("FastQC")` v0.11.8 [@andrewsFASTQCQualityControl2014]. Post-trimming and mapping statistics were consolidated into a single, interactive report for each batch using `r fontFmt("MultiQC")` v1.0 [@ewels_multiqc:_2016]. Files of samples that did not pass the quality thresholds of 20% mapping rate and x15 coverage were discarded from the rest of the analysis.  

#### Macrogen batch
The report from Macrogen was parsed to extract the links and download all the relevant `.fastq.gz` and `.xlsx` files.  
```{bash retrieve_macrogen_files}
mkdir -p ~/scratch/data/A_rabiei_WGS/Macrogen_sequences_1702KHP-0164
cd !$
# Download Macrogen report file into the folder
REPORT_PDF="1702KHP-0164_ALL_20171107141025.pdf"
# Extract all links from the report and download them (skip existing)
pdfx -v $REPORT_PDF | grep "[fastq\.gz|\.xls]" | cut -f2,2 -d " " | parallel wget -nc {}
```

```{bash trim_reads_macrogen}
cd ~/data/A_rabiei_sequencing/Macrogen_sequences_1702KHP-0164
# fix read file names
my_rename -v 's/_([12].fastq)/_R\1/' *.fastq.gz
# Remove duplicate files
my_rename -v 's/.gz/.gz.dup/' 15CUR005*.fastq.gz
# Prepare the commands
DATE=`date +%d_%m_%Y`
BATCH=macrogen
RUN="${BATCH}_BT2_process_${DATE}" # day of run was 02_02_2019
mkdir ${RUN}
cd !$
GENOME="$HOME/scratch/data/reference_genomes/Ascochyta_reference_genomes/A.rabiei_me14"
READ_LENGTH=100
PLOIDY=1
NCORES=12
RGPL=HiSeq2500 
RGPU=HHCLJBCXY
RGCN=Macrogen

# Perform adapter trimming, mapping, deduplication, add RG, sort and index 
find ../ -maxdepth 1 -name "*_R1.fastq.gz" | sort | gawk -F"\t" -v bbmap_dir=$BBMAP_DIR -v genome=$GENOME -v RGPL=$RGPL -v RGPU=$RGPU -v RGCN=$RGCN -v ncores=$NCORES 'BEGIN{command=sprintf("bbduk.sh -Xmx1g ref=%s/resources/adapters.fa ktrim=r k=23 mink=11 hdist=1 qtrim=rl trimq=10 tpe tbo int minlen=30 ziplevel=9 ow", bbmap_dir)};{n=split($1,a,"/"); infile=gensub("_R1\\.", "_R#.", "1", $1); basename=gensub(/(.+)_R1.fastq.gz/, "\\1", "1", a[n]) ; printf("cd $PBS_O_WORKDIR; %s in=%s out=trimmed_%s_R#.fastq.gz stats=%s.stats ow && bowtie2 --very-sensitive -p %s -x %s -1 trimmed_%s_R1.fastq.gz -2 trimmed_%s_R2.fastq.gz --un-conc-gz %s_unmapped.fq.gz --no-unal | samblaster | picard AddOrReplaceReadGroups I=/dev/stdin O=%s_BT2_me14.dedup.rg.csorted.bam SM=%s ID=%s_%s LB=%s_%s PL=%s PU=%s CN=%s CREATE_INDEX=true  SO=coordinate \n", command, infile, basename, basename, ncores, genome, basename, basename, basename, basename, basename, basename, NR, basename, NR, RGPL,RGPU, RGCN)}' > ${RUN}.bash

# Run on parallel nodes (faster and preferred)

# Prepare PBS script
echo '#!/bin/bash -v
#PBS -V
#PBS -l' "select=1:ncpus=$NCORES:mem=96GB,walltime=10:30:00

cd \$PBS_O_WORKDIR
gawk -v ARRAY_IND=\$PBS_ARRAY_INDEX 'NR==ARRAY_IND' \${CMDS_FILE} | bash" > ${RUN}.pbspro

# Run the commands 
JOB_NAME=${RUN}
JOBS_NUM=`wc -l ${RUN}.bash | gawk '{print $1}'`
BT2_ID=$( qsub -J1-$JOBS_NUM -N ${JOB_NAME:0:11} -vCMDS_FILE=${RUN}.bash  ${RUN}.pbspro ) 
BT2_ID=$( echo $BT2_ID | egrep -o "[0-9]{7}"  )
# record the array ID: 5247580[] Macrogen batch on Gowonda

# Run FastQC on the output files
QC_JOB=${BATCH}_trim_qc_"${DATE}"
QC_JOB_ID=$( echo "cd $( pwd ) ; mkdir $QC_JOB; fastqc -t 12 -o $QC_JOB trimmed_*.fastq.gz" | qsub -V -l select=1:ncpus=12:mem=4GB,walltime=1:00:00  -N trim_qc -W depend=afterok:$BT2_ID[] ) # 5248661.pbsserver
QC_JOB_ID=$( echo $QC_JOB_ID | egrep -o "[0-9]{7}" )

# Run qualimap on bam files (files need to be sorted)
QUALIMAP_JOB="${BATCH}_qualimap_${DATE}"

QUALIMAP_JOB_ID=$( echo "cd $( pwd ) ; unset DISPLAY ; ls -1 *.csorted.bam | gawk '{match(\$0, /(.+)_BT2_me14.dedup.rg.csorted.bam/, a); printf \"%s\\t%s\\n\",a[1], \$0 }' > $QUALIMAP_JOB.samples ; qualimap multi-bamqc -r -d $QUALIMAP_JOB.samples -outformat PDF:HTML -outdir $QUALIMAP_JOB -outfile $QUALIMAP_JOB.pdf" | qsub -V -l select=1:ncpus=12:mem=4GB,walltime=1:00:00 -N ${QUALIMAP_JOB:0:11} -W depend=afterok:$BT2_ID[] ) # 5248673.pbsserver
QUALIMAP_JOB_ID=$( echo $QUALIMAP_JOB_ID | egrep -o "[0-9]{7}" )

# multiqc report
MULTIQC_JOB="${BATCH}_BT2_qc_${DATE}"
echo "cd $( pwd ) ; multiqc -i $MULTIQC_JOB -o $MULTIQC_JOB ." | qsub -V -l select=1:ncpus=12:mem=4GB,walltime=1:00:00 -N ${MULTIQC_JOB:0:11} -W depend=afterok:$QUALIMAP_JOB_ID:$QC_JOB_ID # 5248672.pbsserver

# collect mapping stats
cat *.e$BT2_ID.* > ${RUN}.log
egrep "Created read group|overall alignment rate" ${RUN}.log | gawk 'BEGIN{printf "sample_id\tmapping_rate\n"} NR%2==1{match($0, /SM=(.+?)$/, a); printf a[1]} NR%2==0{printf "\t%s\n",$1}'   > ${RUN}.stats.tmp

# collect trimming stats

egrep "Input:|Result:" ${RUN}.log | gawk -v OFS="\t" 'BEGIN{printf "input_reads\tinput_bases\tpost_trim_reads\tpost_trim_bases\n"}NR%2==1{printf "%s\t%s\t",$2,$4}NR%2==0{print $2,$5}' | paste ${RUN}.stats.tmp - >  ${RUN}.stats


# find and remove empty files
find . -size 0 -exec rm {} + 

# Check that all jobs finished successfuly
find . -regextype posix-egrep -regex '\./.*\.e[0-9]{7}.*' | xargs grep "ExitStatus" #  *m.e$JOB_ID.*

```

#### AGRF batch
Download all the raw `.fastq.gz` files from AGRF.
```{bash retrieve_files}
mkdir -p ~/scratch/data/A_rabiei_WGS
# Retrieve all files from AGRF
rsync -avh -e ssh IdoBar1@agrf-data.agrf.org.au:files/AGRF_CAGRF19461_HGMLMAFXY ~/scratch/data/A_rabiei_WGS/
```

```{bash recal_trim_reads_AGRF}
# Prepare the BBduk commands
DATE=`date +%d_%m_%Y`
BATCH=AGRF
RUN="${BATCH}_BT2_process_${DATE}" # day of run was 02_02_2019
mkdir ${RUN}
cd !$
GENOME="$HOME/scratch/data/reference_genomes/Ascochyta_reference_genomes/A.rabiei_me14"
READ_LENGTH=150
NCORES=12
PLOIDY=1
LANES=$( ls -1 ../*.fastq.gz | egrep -o "_L[0-9]+?_" | sort | uniq | wc -l )
RGPL=NextSeq 
RGPU=HGMLMAFXY
RGCN=AGRF

# Combine the read files from each lane (and remove barcode and flowcell information)
MERGE_LANES=${BATCH}_merge_lanes
parallel --dryrun "eval cat {=s/L001/*/=} > {=s:.*/::; s/_HGMLMAFXY_[ACGT-]*_L001//; =}" ::: ../*L001*gz > $MERGE_LANES.cmds

# Prepare PBS script
echo '#!/bin/bash -v
#PBS -V
#PBS -l' "select=1:ncpus=$NCORES:mem=96GB,walltime=10:30:00

cd \$PBS_O_WORKDIR
gawk -v ARRAY_IND=\$PBS_ARRAY_INDEX 'NR==ARRAY_IND' \${CMDS_FILE} | bash" > ${RUN}.pbspro
# Run merge array
MERGE_NUM=$( cat $MERGE_LANES.cmds | wc -l )
MERGE_LANES_ID=$( qsub -J1-$MERGE_NUM -N ${MERGE_LANES:0:11} -vCMDS_FILE=$MERGE_LANES.cmds )
MERGE_LANES_ID=$( echo $MERGE_LANES_ID | egrep -o "[0-9]{7}" )

# Perform adapter trimming, mapping, deduplication, add RG, sort and index 
find ./ -maxdepth 1 -name "*_R1.fastq.gz" | sort | gawk -F"\t" -v bbmap_dir=$BBMAP_DIR -v genome=$GENOME -v RGPL=$RGPL -v RGPU=$RGPU -v RGCN=$RGCN -v ncores=$NCORES 'BEGIN{command=sprintf("bbduk.sh -Xmx1g ref=%s/resources/adapters.fa ktrim=r k=23 mink=11 hdist=1 qtrim=rl trimq=10 tpe tbo int minlen=30 ziplevel=9 ow", bbmap_dir)};{n=split($1,a,"/"); infile=gensub("_R1\\.", "_R#.", "1", $1); basename=gensub(/(.+)_R1.fastq.gz/, "\\1", "1", a[n]) ; printf("cd $PBS_O_WORKDIR; %s in=%s out=trimmed_%s_R#.fastq.gz stats=%s.stats ow && bowtie2 --very-sensitive -p %s -x %s -1 trimmed_%s_R1.fastq.gz -2 trimmed_%s_R2.fastq.gz --un-conc-gz %s_unmapped.fq.gz --no-unal | samblaster | picard AddOrReplaceReadGroups I=/dev/stdin O=%s_BT2_me14.dedup.rg.csorted.bam SM=%s ID=%s_%s LB=%s PL=%s PU=%s CN=%s CREATE_INDEX=true  SO=coordinate \n", command, infile, basename, basename, ncores, genome, basename, basename, basename, basename, basename, basename, NR, basename, RGPL,RGPU, RGCN)}' > ${RUN}.bash

# Run on parallel nodes (faster and preferred)

# Run the commands 
JOB_NAME=${RUN}
JOBS_NUM=`wc -l ${RUN}.bash | gawk '{print $1}'`
BT2_ID=$( qsub -J1-$JOBS_NUM -N ${JOB_NAME:0:11} -vCMDS_FILE=${RUN}.bash  ${RUN}.pbspro ) 
BT2_ID=$( echo $BT2_ID | egrep -o "[0-9]{7}"  )
# record the array ID: 5247580[] Macrogen batch on Gowonda

# Run FastQC on the output files
QC_JOB=${BATCH}_trim_qc_"${DATE}"
QC_JOB_ID=$( echo "cd $( pwd ) ; mkdir $QC_JOB; fastqc -t 12 -o $QC_JOB trimmed_*.fastq.gz" | qsub -V -l select=1:ncpus=12:mem=4GB,walltime=1:00:00  -N trim_qc -W depend=afterok:$BT2_ID[] ) # 5248661.pbsserver
QC_JOB_ID=$( echo $QC_JOB_ID | egrep -o "[0-9]{7}" )

# Run qualimap on bam files (files need to be sorted)
QUALIMAP_JOB="${BATCH}_qualimap_${DATE}"

QUALIMAP_JOB_ID=$( echo "cd $( pwd ) ; unset DISPLAY ; ls -1 *.csorted.bam | gawk '{match(\$0, /(.+)_BT2_me14.dedup.rg.csorted.bam/, a); printf \"%s\\t%s\\n\",a[1], \$0 }' > $QUALIMAP_JOB.samples ; qualimap multi-bamqc -r -d $QUALIMAP_JOB.samples -outformat PDF:HTML -outdir $QUALIMAP_JOB -outfile $QUALIMAP_JOB.pdf" | qsub -V -l select=1:ncpus=12:mem=4GB,walltime=1:00:00 -N ${QUALIMAP_JOB:0:11} -W depend=afterok:$BT2_ID[] ) # 5248673.pbsserver
QUALIMAP_JOB_ID=$( echo $QUALIMAP_JOB_ID | egrep -o "[0-9]{7}" )

# multiqc report
MULTIQC_JOB="${BATCH}_BT2_qc_${DATE}"
echo "cd $( pwd ) ; multiqc -i $MULTIQC_JOB -o $MULTIQC_JOB ." | qsub -V -l select=1:ncpus=12:mem=4GB,walltime=1:00:00 -N ${MULTIQC_JOB:0:11} -W depend=afterok:$QUALIMAP_JOB_ID:$QC_JOB_ID # 5248672.pbsserver

# collect mapping stats
cat *.e$BT2_ID.* > ${RUN}.log
egrep "Created read group|overall alignment rate" ${RUN}.log | gawk 'BEGIN{printf "sample_id\tmapping_rate\n"} NR%2==1{match($0, /SM=(.+?)$/, a); printf a[1]} NR%2==0{printf "\t%s\n",$1}'   > ${RUN}.stats.tmp

# collect trimming stats

egrep "Input:|Result:" ${RUN}.log | gawk -v OFS="\t" 'BEGIN{printf "input_reads\tinput_bases\tpost_trim_reads\tpost_trim_bases\n"}NR%2==1{printf "%s\t%s\t",$2,$4}NR%2==0{print $2,$5}' | paste ${RUN}.stats.tmp - >  ${RUN}.stats


# find and remove empty files
find . -size 0 -exec rm {} + 

# Check that all jobs finished successfuly
find . -regextype posix-egrep -regex '\./.*\.e[0-9]{7}.*' | xargs grep "ExitStatus" #  *m.e$JOB_ID.*
# Done!
```

#### AgriVic batch

```{bash recal_trim_reads_AgVic}
cd ~/scratch/data/A_rabiei_WGS/AgVic_WGS2018
# Prepare the BBduk commands
BATCH=AgriVic
DATE=`date +%d_%m_%Y`
RUN="${BATCH}_BT2_process_${DATE}" # day of run was 02_02_2019
mkdir ${RUN}
cd !$
GENOME="$HOME/scratch/data/reference_genomes/Ascochyta_reference_genomes/A.rabiei_me14"
# LANES=`ls -1 *.fastq.gz | egrep -o "_L[0-9]+?_" | sort | uniq | wc -l`
READ_LENGTH=150
PLOIDY=1
NCORES=12
RGPL=HiSeq3000
RGPU=HWYNNBBXX
RGCN=AgriVic

# fix read file names
ln -s ../*_R*.fastq.gz ./
my_rename -v 's/_L00[1-4]//; s/HWYNNBBXX//' *.fastq.gz
# my_rename -v 's/_001//; s/_L003//' *.fastq.gz

# Perform adapter trimming, mapping, deduplication, add RG, sort and index 
find ./ -maxdepth 1 -name "*_R1.fastq.gz" | sort | gawk -F"\t" -v bbmap_dir=$BBMAP_DIR -v genome=$GENOME -v RGPL=$RGPL -v RGPU=$RGPU -v RGCN=$RGCN -v ncores=$NCORES 'BEGIN{command=sprintf("bbduk.sh -Xmx1g ref=%s/resources/adapters.fa ktrim=r k=23 mink=11 hdist=1 qtrim=rl trimq=10 tpe tbo int minlen=30 ziplevel=9 ow", bbmap_dir)};{n=split($1,a,"/"); infile=gensub("_R1\\.", "_R#.", "1", $1); basename=gensub(/(.+)_R1.fastq.gz/, "\\1", "1", a[n]) ; printf("cd $PBS_O_WORKDIR; %s in=%s out=trimmed_%s_R#.fastq.gz stats=%s.stats ow && bowtie2 --very-sensitive -p %s -x %s -1 trimmed_%s_R1.fastq.gz -2 trimmed_%s_R2.fastq.gz --un-conc-gz %s_unmapped.fq.gz --no-unal | samblaster | picard AddOrReplaceReadGroups I=/dev/stdin O=%s_BT2_me14.dedup.rg.csorted.bam SM=%s ID=%s_%s LB=%s PL=%s PU=%s CN=%s CREATE_INDEX=true  SO=coordinate \n", command, infile, basename, basename, ncores, genome, basename, basename, basename, basename, basename, basename, NR, basename, RGPL,RGPU, RGCN)}' > ${RUN}.bash

# Run on parallel nodes (faster and preferred)
# Prepare PBS script
echo '#!/bin/bash -v
#PBS -V
#PBS -l' "select=1:ncpus=${NCORES}:mem=96GB,walltime=10:30:00

cd \$PBS_O_WORKDIR
gawk -v ARRAY_IND=\$PBS_ARRAY_INDEX 'NR==ARRAY_IND' \${CMDS_FILE} | bash" > ${RUN}.pbspro

# Run the commands 
JOB_NAME=${RUN}
JOBS_NUM=$( wc -l ${RUN}.bash | gawk '{print $1}' )
BT2_ID=$( qsub -J1-$JOBS_NUM -N ${JOB_NAME:0:11} -vCMDS_FILE=${RUN}.bash  ${RUN}.pbspro ) 
BT2_ID=$( echo $BT2_ID | egrep -o "[0-9]{7}"  )
# record the array ID: 5247580[] Macrogen batch on Gowonda

# Run FastQC on the output files
QC_JOB=${BATCH}_trim_qc_"${DATE}"
QC_JOB_ID=$( echo "cd $( pwd ) ; mkdir $QC_JOB; fastqc -t 12 -o $QC_JOB trimmed_*.fastq.gz" | qsub -V -l select=1:ncpus=12:mem=4GB,walltime=1:00:00  -N trim_qc -W depend=afterok:$BT2_ID[] ) # 5248661.pbsserver
QC_JOB_ID=$( echo $QC_JOB_ID | egrep -o "[0-9]{7}" )

# Run qualimap on bam files (files need to be sorted)
QUALIMAP_JOB="${BATCH}_qualimap_${DATE}"

QUALIMAP_JOB_ID=$( echo "cd $( pwd ) ; unset DISPLAY ; ls -1 *.csorted.bam | gawk '{match(\$0, /(.+)_BT2_me14.dedup.rg.csorted.bam/, a); printf \"%s\\t%s\\n\",a[1], \$0 }' > $QUALIMAP_JOB.samples ; qualimap multi-bamqc -r -d $QUALIMAP_JOB.samples -outformat PDF:HTML -outdir $QUALIMAP_JOB -outfile $QUALIMAP_JOB.pdf" | qsub -V -l select=1:ncpus=12:mem=4GB,walltime=1:00:00 -N ${QUALIMAP_JOB:0:11} -W depend=afterok:$BT2_ID[] ) # 5248673.pbsserver
QUALIMAP_JOB_ID=$( echo $QUALIMAP_JOB_ID | egrep -o "[0-9]{7}" )

# multiqc report
MULTIQC_JOB="${BATCH}_BT2_qc_${DATE}"
echo "cd $( pwd ) ; multiqc -i $MULTIQC_JOB -o $MULTIQC_JOB ." | qsub -V -l select=1:ncpus=12:mem=4GB,walltime=1:00:00 -N ${MULTIQC_JOB:0:11} -W depend=afterok:$QUALIMAP_JOB_ID:$QC_JOB_ID # 5248672.pbsserver

# collect mapping stats
cat *.e$BT2_ID.* > ${RUN}.log
egrep "Created read group|overall alignment rate" ${RUN}.log | gawk 'BEGIN{printf "sample_id\tmapping_rate\n"} NR%2==1{match($0, /SM=(.+?)$/, a); printf a[1]} NR%2==0{printf "\t%s\n",$1}'   > ${RUN}.stats.tmp

# collect trimming stats

egrep "Input:|Result:" ${RUN}.log | gawk -v OFS="\t" 'BEGIN{printf "input_reads\tinput_bases\tpost_trim_reads\tpost_trim_bases\n"}NR%2==1{printf "%s\t%s\t",$2,$4}NR%2==0{print $2,$5}' | paste ${RUN}.stats.tmp - >  ${RUN}.stats


# find and remove empty files
find . -size 0 -exec rm {} + 
rm *.tmp

# Check that all jobs finished successfuly
find . -regextype posix-egrep -regex '\./.*\.e[0-9]{7}.*' | xargs grep "ExitStatus" #  *m.e$JOB_ID.*
# Done!
```




#### Contaminations in Macrogen samples
Both the initial QC and the mapping results show that there was a contamination in the DNA samples of at least three isolates: 16CUR019, 15CUR003, FT15023. This conclusion was obvious from the different GC content signatures of the three isolates (figure not shown) compared with the other isolates and from the low mapping rates of these isolates to the _A. rabiei_ reference genome (see bottom of `r tbls(name="mapping_rates",display="cite")`).  
FT15023 in particular hardly contained any reads mappable to the _A. rabiei_ reference genome (<0.1%).  
A sub-sample of the raw reads from isolate FT15023 was matched against the NCBI nucleotide collection (nt) and identified the contamination as of bacterial origin (_Ochrobactrum pituitosum/pseudogrignonense_). 

#### Contaminations in AGRF and AgriVic samples
Both the initial QC and the mapping results show that there was a contamination in the DNA samples of at least three isolates: AGRF_05 (17CUR007), AGRF_08 (TR8102) and AGRF_18 (TR9573). This conclusion was obvious from the different GC content signatures of the three isolates (figure not shown) compared with the other isolates and from the mapping rates of these isolates to the _A. rabiei_ reference genome (see bottom of `r tbls(name="mapping_rates",display="cite")`).   
A sub-sample of the raw reads from isolate TR9573 was matched against the NCBI nucleotide collection (nt) and identified the contamination as of bacterial origin (*Stenotrophomonas maltophilia*).  
Since similar contamination levels were found in the same samples in both the AGRF and AgriVic batches, it's likely that it had originated from our lab.  
To further investigate the origin of the contamination, the reads that didn't map to the _A. rabiei_ genome will be clustered and deduplicated using `r fontFmt("clumpify.sh")` from the `r fontFmt("BBtools")` suite, as described in this [Biostars thread](https://www.biostars.org/p/277013/). The clustered reads will be used to construct "mini-assemblies" from the contaminated samples using `r fontFmt("Tadpole")` from the `r fontFmt("BBtools")` suite.  
The assembled contigs will be BLASTed against the nr NCBI database, with species and kingdom annotation and the 20 most common organisms will be identified from each sample.

Samples with less than 20% mapping and x15 coverage were removed from the rest of the analysis (see highlighted rows in `r tbls(name="mapping_rates",display="cite")`).  
A comparison between the sequencing data and mapping statistics of both batches is provided in `r tbls(name="mapping_sum",display="cite")`.
_To process mapping summary table, copy the `.stats` and `qualimap.html` files into `raw_data` folder_

<!-- ```{bash clumpify_unmapped} -->

<!-- ``` -->


```{r mapping_table, eval=TRUE, echo=FALSE}
#analysis_folder <- "../BB_vars_26_02_2019"
analysis_basename <- "A_rabiei_BT2_Apr_2019"
#variant_method <- "haplo.fb"
# analysis_folder <- "../FB_vars_01_03_2019"
# analysis_outdir <- glue("./output/{variant_method}/")
alignment_method <- "BT2"
mapping_table <- list.files(here("raw_data"), glue::glue(".*{alignment_method}.+.stats"), full.names = TRUE) %>%
                              map_df(read_tsv) %>% 
  # mutate_at(vars(contains("mapped")),  ~as.numeric(sub("%", "", ., fixed=TRUE))/100) %>%
  mutate(Mapping_rate=as.numeric(sub("%", "", mapping_rate, fixed=TRUE))/100, 
         Mapping_tool = "Bowtie2 (v2.3.4.3)", # Bowtie2 (version 2.3.4.3)
         Sample_id=str_extract(.$sample_id, paste(sequencing_table$Submission_id, collapse = "|"))) %>%
  group_by(Sample_id, Mapping_tool) %>%
  summarise(Mapping_rate=mean(Mapping_rate)) %>% ungroup() %>% 
  left_join(sequencing_table,by=c("Sample_id"="Submission_id")) %>%
# mutate( Isolate=sequencing_dict[sample_id]) %>% 
  dplyr::select(Isolate, Mapping_rate, Mapping_tool, Sample_id, Sequencing_Centre) 

# Load qualimap statistics (copy summary html files to raw_data folder)

qualimap_files <- list.files(here("raw_data"), glue::glue(".*{alignment_method}.+multisampleBamQcReport.html"), 
                             full.names = TRUE,  recursive = TRUE)
exclude_columns <- c("Coverage std", "Insert size median")
  # mutate(`Pathog. Group`=samples_table$Pathogenicity[match(samples_table$Isolate, .$Isolate)] ) 
qualimap_results <-  qualimap_files %>% map_df(~htmltab(., which = "//td/b[text() = 'Sample name']/ancestor::table")) %>% 
  rename(Sample_id=`Sample name`, Coverage=`Coverage mean`) %>% 
  dplyr::select(-one_of(exclude_columns)) %>% 
  mutate_at(.vars = vars(-starts_with("Sample")), .funs = as.numeric) %>%
  left_join(., mapping_table) %>% 
  arrange(Isolate, desc(Coverage)) %>% set_names(., gsub(" ", "_", colnames(.))) %>%
  dplyr::select(Isolate, GC_percentage, Mapping_quality_mean, Mapping_rate, Coverage, Mapping_tool, Sample_id, Sequencing_Centre) %>%
  write_csv(filedate(glue::glue("{analysis_basename}_AGRF_Macro_AgVic.mapping.stats"), ".txt",
                     here("output/results"), dateformat = FALSE))

# Summarise mapping results
mapping_summary <- qualimap_results %>% filter(Coverage>20) %>% 
  group_by(Sequencing_Centre) %>% 
  summarise(Coverage=sprintf("x%.2f",mean(Coverage)), 
            Mapping_rate=sprintf("%.2f%%", mean(Mapping_rate, na.rm=TRUE)*100),
                                     Mapping_qual=round(mean(Mapping_quality_mean), 2),
            Files=n()) %>%
  # mutate(Reads_per_file=format(c(2224642.64, 36500108.00), 
  #                              digits = 2, scientific = TRUE)) %>%
  arrange(desc(Sequencing_Centre)) %>% 
  write_csv(filedate(glue::glue("{analysis_basename}_AGRF_Macro_AgVic.mapping.sum"), ".txt", 
                     here("output/results"), dateformat = FALSE))

```

```{r map_stats, eval=TRUE}
datatable(as.data.frame(qualimap_results %>% mutate_if(is.numeric, ~round(., 2))), caption=tbls("mapping_rates")) %>% #, 
          # options = list(dom = 'tf', pageLength = 40)) %>%
  formatStyle("Coverage", target = "row",
  backgroundColor = styleInterval(c(10,20), c('#ef3125', '#feed95', NA))
)

# pander(as.data.frame(qualimap_results), caption=tbls("mapping_rates"), justify="left")

# datatable(as.data.frame(mapping_stats), caption = tbls("mapping_rates"), # , width=10
#           style="default", rownames = FALSE, autoHideNavigation=TRUE) %>% 
#   formatPercentage('Mapping_rate', 2) %>% #formatStyle('Isolate',
#   formatStyle('Mapping_rate',
#     color = styleInterval(c(0.05, 0.5), c('yellow', 'blue', 'black')),
#     backgroundColor = styleInterval(c(0.05, 0.5), c('red', 'yellow',NA))
#   )
```



```{r QC_GC, eval=FALSE, echo=FALSE, out.width='100%', fig.cap=figs("GC_cont")}
include_graphics("plots/fastqc_per_sequence_gc_content_plot.png")
```

#### Assess genome size and ploidy
The sequencing data of 2 isolates with sufficient coverage and no contamination were analyzed for their k-mer content (coverage and distribution) to estimate the genome size and ploidy of the genome. The selected samples were DON001 (isolate 15DON001, Macrogen batch), 7_S40 (isolate F16253-1, AgriVic batch) and AGRF_11 (isolate F17191-1, AGRF batch), see coverage details in `r tbls(name="mapping_rates",display="cite")`.  
k-mer counting and genome ploidy and size estimation were performed with `kmercountexact.sh` (from BBMap v38.34, using the odd numbers in the range of 21-37 as kmers, i.e 21, 23, 25..35, 37 (see [SeqAnsewes thread](http://seqanswers.com/forums/showthread.php?t=64086)).  
Similar analysis can be performed by Jellyfish (see [tutorial](http://koke.asrc.kanazawa-u.ac.jp/HOWTO/kmer-genomesize.html))
```{bash kmer_analysis}

DATE=`date +%d_%m_%Y`
RUN=kmer_analysis_${DATE} # day of run was 02_02_2019
PLOIDY=1
mkdir ${RUN}
cd !$

# Prepare PBS script
echo '#!/bin/bash -x
#PBS -V
#PBS -l select=1:ncpus=12:mem=48GB,walltime=01:30:00

cd $PBS_O_WORKDIR
gawk -v ARRAY_IND=$PBS_ARRAY_INDEX'" 'NR==ARRAY_IND' \${CMDS_FILE} | bash" > ${RUN}.pbspro

# macrogen sample
SAMPLE=DON001
# agrivic sample
SAMPLE=7_S40
ln -s ~/scratch/data/A_rabiei_WGS/AgVic_WGS2018/AgriVic_BT2_process_05_04_2019/trimmed_${SAMPLE}*.fastq.gz ./
# Run on parallel nodes (faster and preferred)
# AGRF batch

SAMPLE=AGRF_11
ln -s ~/scratch/data/A_rabiei_WGS/AGRF_CAGRF19461_HGMLMAFXY/AGRF_BT2_process_04_04_2019/trimmed_${SAMPLE}*.fastq.gz ./
# run BB kmercount
SAMPLES=(DON001 7_S40 AGRF_11)
for SAMPLE in "${SAMPLES[@]}"; do
  seq 21 2 37 | parallel --dry-run kmercountexact.sh k={} in=trimmed_${SAMPLE}_R1.fastq.gz in2=trimmed_${SAMPLE}_R2.fastq.gz khist=${SAMPLE}_khist_k{}.txt peaks=${SAMPLE}_peaks_k{}.txt > ${SAMPLE}_${RUN}.bash
  # Run the commands 
  JOB_NAME=bb_kmer
  JOBS_NUM=$( wc -l ${SAMPLE}_${RUN}.bash | gawk '{print $1}' )
  qsub -J1-$JOBS_NUM -N ${JOB_NAME:0:11} -vCMDS_FILE=${SAMPLE}_${RUN}.bash ${RUN}.pbspro # 5374038[].pbsserver
done

# find and remove empty files
find . -size 0 -exec rm {} + 
rm *.tmp

# Check that all jobs finished successfuly
find . -regextype posix-egrep -regex '\./.*\.e[0-9]{7}.*' | xargs grep "ExitStatus" #  *m.e$JOB_ID.*

# aggregate data from all output files (and transpose)

SAMPLES=(DON001 7_S40 AGRF_11)
cat ${SAMPLES[0]}_peaks_k21.txt | grep "^#" | head -n -1 | sed "s/#//" | cat <( printf "sample\t%s\n" $SAMPLE) - | cut -f1 | paste -s > kmer_peaks_summary.txt
parallel "grep "^#" {1}_peaks_k{2}.txt | head -n -1 | sed "s/#//" | cat  <(echo {1}) - | cut -f2 | paste -s" ::: ${SAMPLES[@]} ::: $(seq 21 2 37)
# for SAMPLE in "${SAMPLES[@]}"; do
#  ls -1 ${SAMPLE}_peaks*.txt | parallel "grep "^#" {} | head -n -1 | sed "s/#//" | cat  <(echo $SAMPLE) - | cut -f2 | paste -s" >> kmer_peaks_summary.tst
#  done

# do the same for the hist data (maybe with gawk)
gawk 'NR==1{printf "Sample\tkmer\t%s\n", $0}' ${SAMPLES[0]}_khist_k21.txt | sed "s/#//"  >  khist_summary.txt
parallel "tail -n +2 {1}_khist_k{2}.txt | gawk '{print \"{1}\t{2}\t\"\$0}'" ::: ${SAMPLES[@]} ::: $(seq 21 2 37) >> khist_summary.txt

# Done!

```

The resulting kmer count data for all samples and kmers was aggregated into tables and summarised in the following plot (`r figs(name="kmer_peaks", display="cite")`).  
The single peak observed by the k-mer analysis predicted that _A. rabiei_ genome is haploid, with a genome size of approximately 42 Mbp, with slight variation due to the coverage depth of the sample, regardless of the chosen k-mer length. The lower depth of coverage of sample AGRF_11 led to inflated genome size prediction.

``` {r kmer_plot, eval=TRUE, echo=FALSE, fig.dim=c(7,10), fig.cap=figs(name="kmer_peaks")}
kmer_hist <- read_tsv("raw_data/khist_summary.txt") %>% 
  set_names(., c("Sample", "kmer", "Depth", "Count", "logScale"))
# kmer_hist %>% group_by(Sample) %>% slice(max(main_peak))

kmer_peaks <- read_tsv("raw_data/kmer_peaks_summary.txt")
# summarise peaks to calculate average predicted genome size and 
peaks_summary <- kmer_peaks %>% group_by(sample) %>% rename(Sample=sample) %>% 
  summarise(mean_genome_size=mean(genome_size),genome_size_SE=se(genome_size), max_cov=max(main_peak), 
            ploidy=max(ploidy)) %>% 
  arrange(max_cov) %>% mutate(Sample=forcats::fct_inorder(Sample), 
                              genome_label=sprintf("%s\u2009bp (±%s)", scales::comma(mean_genome_size/1000), 
                                           round(genome_size_SE, digits = 0)))
# limit range (ignore unique kmers with very low depth)
plot_hist <- kmer_hist %>% filter(Depth<200, Depth>2) %>% 
  mutate(kmer=factor(kmer), Sample=factor(Sample, levels = levels(peaks_summary$Sample)))#, kmer==31) #  

# filter(k==31) %>% rename(Sample=sample)

# plot for each kmer (check out the following to support UniCODE characters: https://stackoverflow.com/questions/12768176/unicode-characters-in-ggplot2-pdf-output) , thin space: \u2009
ggplot(plot_hist, mapping = aes(x=Depth, y=Count, colour=kmer)) + 
  scale_y_continuous(labels = scales::comma) +
  geom_line(size=1) + scale_color_paletteer_d("pals::tol") + # ggsci, default_aaas; RColorBrewer, Set1; awtools, mpalette
  facet_wrap(vars(Sample), ncol = 1) + plot_theme() + 
  geom_text(aes(x=15, y=2.0e6, 
                label=sprintf("Predicted ploidy=%sn\nGenome size=%s(±%s) Kbp", ploidy, 
                              scales::comma(mean_genome_size/1000), round(genome_size_SE/1000, digits = 1))),  
                        # format(genome_size, scientific = TRUE, digits = 3))) / comma(genome_size)
            data=peaks_summary, hjust=0, colour="black", size=5)
```

### Variant Call
#### Using FreeBayes
The recalibrated alignment files of duplicate samples (excluding the ones that did not pass QC) were combined to increase coverage and standardise sample names as isolates (set as read groups). The isolate BAM files were merged once more into a single file that was used as input for `r fontFmt("FreeBayes")` v1.2.0 [@garrison_haplotype-based_2012] to assign variant probability scores and call variants.

```{bash FB_var_call_combined}
PLOIDY=1
DATE=`date +%d_%m_%Y`
RUN=FB_vars_${DATE} # day of run was 02_02_2019
mkdir -p $HOME/scratch/data/A_rabiei_WGS/${RUN}
cd !$
# JOB_NAME="BBmap_me14_vars"
GENOME="$HOME/scratch/data/reference_genomes/Ascochyta_reference_genomes/A.rabiei_me14"
NCORES=12

# link all sam files in the same folder
ln -s ~/scratch/data/A_rabiei_WGS/AgVic_WGS2018/AgriVic_BT2_process_05_04_2019/*.csorted.bam ./
ln -s ~/scratch/data/A_rabiei_WGS/AGRF_CAGRF19461_HGMLMAFXY/AGRF_BT2_process_04_04_2019/*.csorted.bam ./
ln -s ~/data/A_rabiei_sequencing/Macrogen_sequences_1702KHP-0164/macrogen_BT2_process_03_04_2019/*.csorted.bam ./

MERGE_JOB="merge_bams"
mkdir -p $MERGE_JOB
cd !$

IGNORE_SAMS='11_S44|5B_S38|2_S34|11_S44|15CUR005|AGRF_18|AGRF_08|F15023|20_S53'
# merge sam files of duplicated samples and rename to isolate name
 egrep -v $IGNORE_SAMS $HOME/scratch/data/A_rabiei_WGS/A_rabiei_isolate_list_for_wgs.txt | tail -n+2 | sort -k2 | gawk  -v ORS="" 'BEGIN{cmd="cd $PBS_O_WORKDIR; picard MergeSamFiles USE_THREADING=true QUIET=true COMPRESSION_LEVEL=0 O=/dev/stdout"}NR==1{printf "%s I=../%s_BT2_me14.dedup.rg.csorted.bam", cmd, $1; isolate=$2; next}isolate!=$2{printf " | picard AddOrReplaceReadGroups SO=coordinate I=/dev/stdin ID=%s LB=%s PL=Illumina PU=combined SM=%s O=%s.csorted.bam\n%s I=../%s_BT2_me14.dedup.rg.csorted.bam", isolate, isolate, isolate,  isolate, cmd, $1; isolate=$2; next}isolate==$2{printf " I=../%s_BT2_me14.dedup.rg.csorted.bam", $1}END{printf " | picard AddOrReplaceReadGroups SO=coordinate I=/dev/stdin ID=%s LB=%s PL=Illumina PU=mixed SM=%s O=%s.csorted.bam\n", isolate, isolate, isolate,  isolate}'  > $MERGE_JOB.cmds
 
# Prepare PBS script
echo '#!'"/bin/bash -v
#PBS -V
#PBS -l select=1:ncpus=${NCORES}:mem=64GB,walltime=01:30:00

cd \$PBS_O_WORKDIR
gawk -v ARRAY_IND=\$PBS_ARRAY_INDEX 'NR==ARRAY_IND' \${CMDS_FILE} | bash" > $MERGE_JOB.pbspro

MERGE_JOB_ID=$( qsub -J1-$( wc -l $MERGE_JOB.cmds | gawk '{print $1}' ) -N $MERGE_JOB -vCMDS_FILE=$MERGE_JOB.cmds $MERGE_JOB.pbspro )
# 5248653[].pbsserver
MERGE_JOB_ID=$( echo $MERGE_JOB_ID | egrep -o "[0-9]{7}")

# check jobs completion
grep "ExitStatus"  *.e$MERGE_JOB_ID*
# remove links
find . -type l -exec rm {} +
cd - 

# merge again to a single file
BAMS=$( ls -1 $MERGE_JOB/*.csorted.bam | gawk -v ORS=" " '{print "I="$1}' )
BAM_FILES=$(  egrep -v $IGNORE_SAMS $HOME/scratch/data/A_rabiei_WGS/A_rabiei_isolate_list_for_wgs.txt | tail -n+2 | sort -k2 | cut -f2,2 | uniq  | gawk -vORS=" " '{print "merge_bams/"$1".csorted.bam"}' )
FINAL_MERGE=$( echo "cd $( pwd ) ; sambamba merge -t $NCORES -l 8 all.csorted.combined.bam $BAM_FILES " | qsub -V -l select=1:ncpus=${NCORES}:mem=96GB,walltime=5:00:00 -N Final_merge -W depend=afterok:$MERGE_JOB_ID[]) 
#FINAL_MERGE=$( echo "cd $( pwd ) ; picard MergeSamFiles USE_THREADING=true SO=coordinate $BAMS O=all.csorted.combined.bam" | qsub -V -l select=1:ncpus=${NCORES}:mem=96GB,walltime=5:00:00 -N Final_merge ) # 5248672.pbsserver
FINAL_MERGE_ID=$( echo $FINAL_MERGE | egrep -o "[0-9]{7}")

# save read groups to file
sambamba view -H all.csorted.combined.bam | grep "^@RG" > all_read_groups.txt
# BAM_FILES=$( ls -1 $MERGE_JOB/*.csorted.bam | gawk -vORS=" " '1' )
# calculate coverage
CALC_COV=$( echo "cd $( pwd ) ;  sambamba depth base --combined all.csorted.combined.bam | cut -f 1-3 | tail -n +2 | coverage_to_regions.py $GENOME.fasta.fai 500 > targets.regions " | qsub -V -l select=1:ncpus=${NCORES}:mem=96GB,walltime=5:00:00 -N Calc_cov -W depend=afterok:$FINAL_MERGE_ID ) # 5248672.pbsserver
CALC_COV_ID=$( echo $CALC_COV | egrep -o "[0-9]{7}")
# /export/home/s2978925/.pyenv/versions/miniconda2-latest/bin/bamtools coverage -in
# prepare Freebayes commands
FB=freebayes_${DATE}
FB_CMDS=$( echo "cd $( pwd ) ; cat targets.regions | parallel --dry-run -k \"freebayes -p $PLOIDY -f $GENOME.fasta all.csorted.combined.bam --region {}\" > $FB.cmds" | qsub -V -l select=1:ncpus=${NCORES}:mem=96GB,walltime=5:00:00 -N FB_cmds -W depend=afterok:$CALC_COV_ID ) # 5248672.pbsserver
# get job_id
FB_CMDS_ID=$( echo $FB_CMDS | egrep -o "[0-9]{7}")

# Send freebayes jobs to the cluster
# Prepare PBS script
echo '#!'"/bin/bash -v
#PBS -V
#PBS -l select=1:ncpus=${NCORES}:mem=64GB,walltime=20:00:00
"'
cd $PBS_O_WORKDIR
ARRAYID=$( echo $PBS_ARRAY_ID | egrep -o "[0-9]{7}" )
gawk -v ARRAY_IND=$PBS_ARRAY_INDEX'" 'NR>(${NCORES}*3*(ARRAY_IND-1)) && NR<=(ARRAY_IND*${NCORES}*3)' \${CMDS_FILE} | parallel -k -j ${NCORES} --joblog"' ${CMDS_FILE}.p$ARRAYID.$PBS_ARRAY_INDEX' > freebayes.pbspro

NCMDS=$( wc -l $FB.cmds | gawk '{print $1}')
NJOBS=$(( NCMDS/NCORES/3 + 1  ))
FB_JOB=$( qsub -J1-$NJOBS -N ${FB:0:11} -W depend=afterok:$FB_CMDS_ID -vCMDS_FILE=$FB.cmds freebayes.pbspro )
# 5270639[1-4] completed successfully (the rest needed more processing time)
FB_JOB_ID=$( echo $FB_JOB | egrep -o "[0-9]{7}")

CONCAT_FB=$( echo "cd $( pwd ) ; cat *.o$FB_JOB_ID* | vcffirstheader | vcfstreamsort -w 1000 | vcfuniq > A_rabiei_2018_isolates_haplo.fb.vcf" | qsub -V -l select=1:ncpus=${NCORES}:mem=96GB,walltime=10:00:00 -N FB_vcf -W depend=afterok:$FB_JOB_ID[] -m e -M i.bar@griffith.edu.au)
CONCAT_FB_ID=$( echo $CONCAT_FB | egrep -o "[0-9]{7}" )

# check for success/failure of FB commands
tail -n +2 $FB.cmds.p*.* | cut -f7,9 | gawk '$1==1' > $FB.failed.cmds
tail -n +2 $FB.cmds.p*.* | cut -f7,9 | gawk '$1==0' > $FB.successful.cmds

# Produce vcf stats
SAMPLES=$( cut -f6 all_read_groups.txt | gawk -F":" -vORS="," '{print $2}' | sed 's/,$//' )
FB_STATS=$( echo "cd $( pwd ) ; mkdir ${FB}_stats; bcftools stats -F $GENOME.fasta -s $SAMPLES A_rabiei_2018_isolates_haplo.fb.vcf > ${FB}_stats/A_rabiei_2018_isolates_haplo.fb.vcf.stats; plot-vcfstats -p ${FB}_stats ${FB}_stats/A_rabiei_2018_isolates_haplo.fb.vcf.stats" | qsub -V -l select=1:ncpus=${NCORES}:mem=96GB,walltime=10:00:00 -N FB_vcfstats -W depend=afterok:$CONCAT_FB_ID -m e -M i.bar@griffith.edu.au)
FB_STATS_ID=$( echo $FB_STATS | egrep -o "[0-9]{7}" )

# find and remove empty files
find . -size 0 -exec rm {} +

# check jobs completion
find . -regextype posix-egrep -regex '\./.*\.e[0-9]{7}.*' | xargs grep "ExitStatus"

```

It is advised to process each sample separately as well to be able to estimate error rates and expected relatedness between duplicate samples from the same isolate.

```{bash FB_var_call_ind}
PLOIDY=1
DATE=`date +%d_%m_%Y`
RUN=FB_vars_ind_${DATE} # day of run was 02_02_2019
mkdir -p $HOME/scratch/data/A_rabiei_WGS/${RUN}
cd !$
# JOB_NAME="BBmap_me14_vars"
GENOME="$HOME/scratch/data/reference_genomes/Ascochyta_reference_genomes/A.rabiei_me14"
NCORES=12

# get number of reads from all input files
mkdir raw_fq
cd !$
ln -s ~/scratch/data/A_rabiei_WGS/AgVic_WGS2018/*.f*q.gz ./
ln -s ~/scratch/data/A_rabiei_WGS/AGRF_CAGRF19461_HGMLMAFXY/AGRF_BB_process_22_02_2019/AGRF_*R?.f*q.gz ./
ln -s ~/data/A_rabiei_sequencing/Macrogen_sequences_1702KHP-0164/*.f*q.gz ./
# remove flowcell and barcode information
my_rename -v 's/_L00[1-9]//; s/_HGMLMAFXY_[ACGT-]+//' *.f*q.gz #  
# calculate number of reads for each pair
FQ_STATS=$(  find `pwd` -name "*.f*q.gz" | parallel --dry-run "printf '{/.}\t{=s/.+_(R[12]).fastq.gz/\1/=}\t%s\n' \$(( \$(pigz -cd {} | wc -l)/4 ))" | qsub -V -l select=1:ncpus=${NCORES}:mem=96GB,walltime=5:00:00 -N read_stats )
FQ_STATS_ID=$( echo $FQ_STATS | egrep -o "[0-9]{7}" )
cp read_stats.o$FQ_STATS_ID ../${RUN}_raw_reads.tsv
cd - 

# process bams
mkdir ind_bams

# link all sam files in the same folder
ln -s ~/scratch/data/A_rabiei_WGS/AgVic_WGS2018/AgriVic_BT2_process_05_04_2019/*.csorted.bam ./ind_bams/
ln -s ~/scratch/data/A_rabiei_WGS/AGRF_CAGRF19461_HGMLMAFXY/AGRF_BT2_process_04_04_2019/*.csorted.bam ./ind_bams/
ln -s ~/data/A_rabiei_sequencing/Macrogen_sequences_1702KHP-0164/macrogen_BT2_process_03_04_2019/*.csorted.bam ./ind_bams/
# remove lane information
my_rename -v 's/_L00[1-9]//' *L00*.bam
MERGE_JOB="merge_bams"

IGNORE_SAMS='11_S44|5B_S38|2_S34|11_S44|15CUR005|AGRF_18|AGRF_08|F15023|20_S53'

# merge ind files to a single bam file (keep submission ids)
# BAMS=$( ls -1 $MERGE_JOB/*.csorted.bam | egrep -v $IGNORE_SAMS| gawk -v ORS=" " '{print "I="$1}' )
BAM_FILES=$( ls -1 ind_bams/*.csorted.bam | egrep -v $IGNORE_SAMS | gawk -vORS=" " '1' )
FINAL_MERGE=$( echo "cd $( pwd ) ; sambamba merge -t $NCORES all_ind.csorted.combined.bam $BAM_FILES" | qsub -V -l select=1:ncpus=${NCORES}:mem=96GB,walltime=5:00:00 -N Final_merge ) # 5248672.pbsserver
FINAL_MERGE_ID=$( echo $FINAL_MERGE | egrep -o "[0-9]{7}")


# BAM_FILES=$( ls -1 $MERGE_JOB/*.csorted.bam | gawk -vORS=" " '1' )

# calculate coverage
CALC_COV=$( echo "cd $( pwd ) ;  sambamba depth base --combined all_ind.csorted.combined.bam | cut -f 1-3 | tail -n +2 | coverage_to_regions.py $GENOME.fasta.fai 500 > targets.regions " | qsub -V -l select=1:ncpus=${NCORES}:mem=96GB,walltime=5:00:00 -N Calc_cov -W depend=afterok:$FINAL_MERGE_ID ) # 5248672.pbsserver
CALC_COV_ID=$( echo $CALC_COV | egrep -o "[0-9]{7}")
# /export/home/s2978925/.pyenv/versions/miniconda2-latest/bin/bamtools coverage -in
# prepare Freebayes commands
FB=freebayes_${DATE}
FB_CMDS=$( echo "cd $( pwd ) ; cat targets.regions | parallel --dry-run -k \"freebayes -p $PLOIDY -f $GENOME.fasta all_ind.csorted.combined.bam --region {}\" > $FB.cmds" | qsub -V -l select=1:ncpus=${NCORES}:mem=96GB,walltime=5:00:00 -N FB_cmds -W depend=afterok:$CALC_COV_ID ) # 5248672.pbsserver
# get job_id
FB_CMDS_ID=$( echo $FB_CMDS | egrep -o "[0-9]{7}")

# Send freebayes jobs to the cluster
# Prepare PBS script
echo '#!'"/bin/bash -v
#PBS -V
#PBS -l select=1:ncpus=${NCORES}:mem=64GB,walltime=20:00:00
"'
cd $PBS_O_WORKDIR
ARRAYID=$( echo $PBS_ARRAY_ID | egrep -o "[0-9]{7}" )
gawk -v ARRAY_IND=$PBS_ARRAY_INDEX'" 'NR>=(${NCORES}*3*(ARRAY_IND-1)) && NR<=(ARRAY_IND*${NCORES}*3)' \${CMDS_FILE} | parallel -k -j ${NCORES} --joblog"' ${CMDS_FILE}.p$ARRAYID.$PBS_ARRAY_INDEX' > freebayes.pbspro

# check jobs completion
find . -regextype posix-egrep -regex '\./.*\.e[0-9]{7}.*' | xargs grep "ExitStatus"

# save read groups to file


# After successful creation of the jobs
NCMDS=$( wc -l $FB.cmds | gawk '{print $1}')
NJOBS=$(( NCMDS/NCORES/3 + 1  ))
FB_JOB=$( qsub -J1-$NJOBS -N ${FB:0:11}  -vCMDS_FILE=$FB.cmds freebayes.pbspro ) # 5270639[1-4] completed successfully (the rest needed more processing time)
FB_JOB_ID=$( echo $FB_JOB | egrep -o "[0-9]{7}")

CONCAT_FB=$( echo "cd $( pwd ) ; cat *.o$FB_JOB_ID* | vcffirstheader | vcfstreamsort -w 1000 | vcfuniq > A_rabiei_2018_isolates_haplo_ind.bt2.fb.vcf; sambamba view -H all_ind.csorted.combined.bam | grep '^@RG' > ind_read_groups.txt" | qsub -V -l select=1:ncpus=${NCORES}:mem=96GB,walltime=10:00:00 -N FB_vcf -W depend=afterok:$FB_JOB_ID[] -m e -M i.bar@griffith.edu.au)
CONCAT_FB_ID=$( echo $CONCAT_FB | egrep -o "[0-9]{7}" )

# find and remove empty files
find . -size 0 -exec rm {} +

# check jobs completion
find . -regextype posix-egrep -regex '\./.*\.e[0-9]{7}.*' | xargs grep "ExitStatus"

# check for success/failure of FB commands
tail -n +2 $FB.cmds.p*.* | cut -f7,9 | gawk '$1==1' > $FB.failed.cmds
tail -n +2 $FB.cmds.p*.* | cut -f7,9 | gawk '$1==0' > $FB.successful.cmds
rm $FB.cmds.p*.*

# Produce vcf stats
SAMPLES=$( cut -f6 ind_read_groups.txt | gawk -F":" -vORS="," '{print $2}' | sed 's/,$//' )
FB_STATS=$( echo "cd $( pwd ) ; mkdir ${FB}_stats; bcftools stats -F $GENOME.fasta -s $SAMPLES A_rabiei_2018_isolates_haplo_ind.bt2.fb.vcf > ${FB}_stats/A_rabiei_2018_isolates_haplo_ind.bt2.fb.vcf.stats; plot-vcfstats -p ${FB}_stats ${FB}_stats/A_rabiei_2018_isolates_haplo_ind.bt2.fb.vcf.stats" | qsub -V -l select=1:ncpus=${NCORES}:mem=96GB,walltime=10:00:00 -N FB_vcfstats -W depend=afterok:$CONCAT_FB_ID -m e -M i.bar@griffith.edu.au)
FB_STATS_ID=$( echo $FB_STATS | egrep -o "[0-9]{7}" )

# find and remove empty files
find . -size 0 -exec rm {} +

```

#### VCF filtering
Variants were filtered using `r fontFmt("SnpSift")` v4.3.1 [@ruden_using_2012], based on their total loci depth, keeping only SNP loci with at least 100 reads covering the locus (DP$\ge 100$) and not more than 20000 (based on EDA). In addition, each isolate genotype call was removed (recoded as `./.`) if it had read depth <5.
```{bash vcf_filter}
# Recode genotypes as missing if below a certain threshold, such as genotyping quality or depth (GQ:DP)  
# filter only polymorphic SNPs, using QUAL>20, DP<36000/20000
QUAL=10
MAX_DP=20000
MIN_DP=20
# filter individual vcf
SnpSift filter "( QUAL>$QUAL ) & ( TYPE='snp' ) & ( DP<$MAX_DP ) & ( DP>$MIN_DP ) & ( countRef()>=1 & countVariant()>=1 )" A_rabiei_2018_isolates_haplo_ind.bt2.fb.vcf | SnpSift gtfilter -gv './.' "( DP<5 )" > A_rabiei_2018_isolates_haplo_ind.bt2.fb.Qual${QUAL}.U${DP}DP.poly.snps.vcf
# filter combined BAM vcf
SnpSift filter "( QUAL>$QUAL ) & ( TYPE='snp' ) & ( DP<$DP ) & ( DP>$MIN_DP )& ( countRef()>=1 & countVariant()>=1 )" A_rabiei_2018_isolates_haplo.fb.vcf | SnpSift gtfilter -gv './.' "( DP<5 )" > A_rabiei_2018_isolates_haplo.Qual${QUAL}.U${DP}DP.poly.snps.vcf

# make tfam file
SnpSift vcf2tped -onlySnp A_rabiei_2018_isolates.tfam A_rabiei_2018_isolates_haplo.Qual20.U20kDP.poly.snps.vcf A_rabiei_2018_isolates # A_rabiei_on_me14_DP_filtered 
```


### Variant Annotation
Variants were then further filtered to keep only polymorphic and bi-allelic SNPs using the `r fontFmt("VariantAnnotation")` v`r packageVersion("VariantAnnotation")` and `r fontFmt("GenomicRanges")` v`r packageVersion("GenomicRanges")` R Bioconductor packages [@obenchain_variantannotation:_2014; @lawrence_software_2013]. The SNPs were annotated and position of each variant relative to gene locations was determined (coding/intron/promotor/intergenic), based on the reference genome and gene models of _A. rabiei_ strain _Me14_ (where the contig names were shortened to remove the `Arab_Me14` prefix). 

```{bash fix_contig_names}
cat A.rabiei_me14.fasta | sed 's/Arab_Me14_//' > A_rabiei_me14_short_names.fasta
zcat Arab_me14.gff3.gz | sed 's/Arab_Me14_//' > Arab_me14_short_names.gff
```

Variants in coding regions of genes were identified as Synonymous/Non-synonymous/Non-sense mutations if they were silent, changing the amino acid or the reading frame, respectively. Additional annotation of the genes at each SNP site was performed by a BLASTp search against the NCBI non-redundant protein database (nr) and scanning against the InterPro conglomerate dbs. Effector prediction of the variant-associated genes was performed by `r fontFmt("EffectorP")` v1.0/2.0 [@SperschneiderEffectorPpredictingfungal2016;@JanaImprovedpredictionfungal2018]. The variants were summarised and visualised across the genome scaffolds and visualised using `r fontFmt("circlize")` v`r packageVersion("circlize")` R package [@gu_circlize_2014].

```{bash interproscan}
# Download the python wrapper

$HPC_GRID_RUNNER_DIR/BioIfx/hpc_FASTA_GridRunner.pl --cmd_template "cd $PBS_O_WORKDIR; pyenv shell miniconda3-latest; ~/etc/tools/Annotation/InterPro/iprscan5_urllib3.py --sequence=__QUERY_FILE__ --outfile=__QUERY_FILE__.interpro.tsv --outformat=tsv --goterms --pathways --email=i.bar@griffith.edu.au " --query_fasta Assoc_SNP_genes_cds_05_02_2018.fasta -G $HPC_GRID_RUNNER_DIR/hpc_conf/small_PBS_jobs.conf -N 1 -O SNP_interpro
```

Look for particular effector genes and genes associated with plant-pathogen interactions and pathogenicity genes. Look in the literature and create a list of target genes.

### Variant-Pathogenicity association
Association between variants and pathogenicity levels was identified by `r fontFmt("SNPassoc")` v`r packageVersion("SNPassoc")` R package [@gonzalez_snpassoc:_2007], using a codominant gene model and a significance threshold of _p_-value $\le0.005$.  



## Appendix 1. Useful resources

* Whole-Genome Comparison of _Aspergillus fumigatus_ Strains Serially Isolated from Patients with Aspergillosis. [@hagiwara_whole-genome_2014]:

> **Sequence analysis:** The Illumina data sets were trimmed using fastq-mcf in ea-utils (version 1.1.2-484), i.e., sequencing adapters and sequences with low quality scores (Phred score [Q], <30) were removed (24). The data sets were mapped to the genome sequence of the _A. fumigatus_ genome reference strain Af293 (29,420,142 bp, genome version s03-m04-r03) (25, 26) using Bowtie 2 (version 2.0.0-beta7) with the very sensitive option in end-to-end mode (27). Duplicated reads were removed using Picard (version 1.112) (<http://picard.sourceforge.net>). The programs mpileup and bcftools from SAMtools (version 0.1.19-44428cd) were used to perform further quality controls. In mpileup, the -q20 argument was used to trim reads with low-quality mapping, whereas the argument -q30 was used to trim low-quality bases at the 3' end (28). The bcftools setting was set to -c in order to call variants using Bayesian inference. Consensus and single nucleotide polymorphisms (SNPs) were excluded if they did not meet a minimum coverage of 5x or if the variant was present in <90% of the base calls (29, 30). The genotype field in the variant call format (VCF) files indicates homozygote and heterozygote probabilities as Phred-scaled likelihoods. SNPs were excluded if they were called as heterozygous genotypes using SAMtools. The mapping results were visualized in the Integrative Genomics Viewer (version 2.3.3) (31, 32). The reference genome data included information on open reading frames and annotations, from which the SNPs were designated non-synonymous or synonymous.  
Single nucleotide mutations were confirmed by Sanger sequencing. Regions of approximately 400 bp that contained a mutation were amplified with appropriately designed primer pairs and then sequenced. The primer sequences are listed in Table S1 in the supplemental material, which were named as follows. For verification of the SNPs in strains from patient I or patient II, PaI or PaII was added to the primer name, respectively. For non-synonymous SNPs, synonymous SNPs, or SNPs in a non-coding region, (NS, Syno, NonC) was added to the primer name, respectively.  
**Analysis of unmapped reads:** _De novo_ assembly of the unmapped reads was conducted using the Newbler assembler 2.9 (Roche), with default parameters. The contigs were selected based on size/depth criteria: those of <500 bp and/or with a depth of <30x coverage were removed. To investigate whether unique genome sequences were present in strains isolated from the same patient, the unmapped reads of each strain were mapped to the contigs generated from all the strains in the same patient by the Bowtie 2 software. The coverage of the mapped regions was then evaluated. Gene predictions were performed using the gene prediction tool AUGUSTUS (version 2.5.5), with a training set of  _A. fumigatus_ (33). The parameters of AUGUSTUS were -species = aspergillus_fumigatus, -strand = both, -genemodel = partial, -singlestrand = false, -protein = on, -introns = on, -start = on, -stop = on, -cds = on, and -gff3 = on. To compare all the predicted genes with _Aspergillus_ genes, consisting of 244,811 genes available on AspGD (34), a reciprocal BLAST best hit approach was performed by BLASTp (35), with an E value of 1.0e<sup>-4</sup>. All BLASTp results were filtered based on a BLASTp identity of $\ge 80$% and an aligned length coverage of $\ge 80$%.

## General information
This document was last updated at `r Sys.time()` using R Markdown (built with `r R.version.string`). Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. It is especially powerful at authoring documents and reports which include code and can execute code and use the results in the output. For more details on using R Markdown see <http://rmarkdown.rstudio.com> and [Rmarkdown cheatsheet](https://www.rstudio.com/wp-content/uploads/2016/03/rmarkdown-cheatsheet-2.0.pdf).

***
## Bibliography

<!-- ```{r results='asis', eval=TRUE} -->
<!-- PrintBibliography(biblio) -->
<!-- ``` -->

