---
title: "Whole Genome Sequencing of <i>Ascochyta rabiei</i> Isolates"
author: "Ido Bar"
date: "11 April 2021"
always_allow_html: yes
output: 
    # md_document:
#      css: "style/style.css"
      # toc: true
      # toc_depth: 3
#      highlight: pygments
#      number_sections: false
    html_document:
      css: "style/style.css"
      toc: true
      toc_float: true
      toc_depth: 3
      highlight: pygments
      number_sections: false
      code_folding: hide
#      keep_md: true
bibliography: style/Fungal_genomes.bib
csl: style/springer-basic-improved-author-date-with-italic-et-al-period.csl
---

```{r setup, include=FALSE}
devtools::source_gist("7f63547158ecdbacf31b54a58af0d1cc", filename = "util.R")
knitr::opts_chunk$set(list(echo = TRUE, eval=FALSE, message=FALSE))
# options(width = 180)
cran_packages <- c("tidyverse", "knitr", "pander", "captioner", "DT", "htmltab")
chooseCRANmirror(ind=1)
pacman::p_load(char=cran_packages)
# Connect to Zotero to access references
# biblio <- ReadBib("data/Fungal_genomes.bib") # , "bibtex", "RefManageR"
# Font Format
custom_font="consolas"
fontFmt = function(x,font="consolas"){
  #outputFormat = knitr::opts_knit$get("rmarkdown.pandoc.to")
  #if (outputFormat == 'html')
  formatted_text <- sprintf("<font face='%s'>%s</font>",font,x)
  return(formatted_text)
  #else
  #  x
}
```



```{r captions, include=FALSE, eval=TRUE}
figs <- captioner(prefix="Figure")
tbls <- captioner(prefix="Table")
tbls(name="samples","Ascochyta rabiei isolates used for DNA sequencing.")
tbls(name="tfam","PLINK's .tfam file format.")
tbls(name="mapping_rates", "Mapping rates of the WGS reads to the Ascochyta rabiei Me14 reference genome.")
tbls(name="mapping_sum", "Mapping statistics for 2017 and 2018 sequencing batches.")
figs(name="GC_cont", "GC (%) content in trimmed WGS reads.")
isolate_table <- readxl::read_excel("./sample_info/A_rabiei_isolate_list_for_wgs.xlsx", sheet = "Sequenced")
sequencing_table <- readxl::read_excel("./sample_info/A_rabiei_isolate_list_for_wgs.xlsx", sheet = "submission_info") 
sequencing_dict <- set_names(sequencing_table$Isolate, sequencing_table$Submission_id)
samples_table <- isolate_table %>% arrange(desc(Pathogenicity), desc(Collection_Year), Site)

#readxl::read_excel("../P_rabiei_isolate_list_for_wgs.xlsx", sheet = "Sequenced") %>%
  # filter(!is.na(Sequenced))  %>% inner_join(isolate_table) %>%
  # mutate(Collection_Year=as.character(isolate_table$Year[match(Isolate, isolate_table$isolate_name)]),
  #        Collection_Year=if_else(!is.na(Collection_Year), Collection_Year, 
  #                         paste0("20", sub("[A-Z]*(\\d{2}).+", "\\1", Isolate)))) %>%
  # dplyr::select(Isolate, Site, State, Collection_Year, Rating, Pathogenicity,Haplotype) %>%
   # %>% write_csv("isolate_list_WGS_2018.csv")
# xlsx::write.xlsx(as.data.frame(samples_table))
tfam_table <- samples_table  %>% dplyr::select(State, Isolate) %>%
  mutate(V3=0, V4=0, V5=0, V6=-9)
#figs(name="WtFreq1","Weight frequency of Ruffe captured in 1992.")

```

# Experimental Design
In 2021, DNA was extracted from 197 isolates of _Ascochyta rabiei_ and sent for Whole-Genome-Sequencing (WGS) on an Illumina HiSeq2500, producing 100 bp short paired-end reads (Macrogen, Korea; detailed sequencing report can be found at `Macrogen_report_1702KHP-0164.pdf` file).  
In the following year (2018), DNA from 20 additional *A. rabiei* isolates was extracted and sent for WGS, first to AgriBio, Centre for AgriBioscience, Agriculture Victoria Research ([Dimpy](mailto:sukhjiwan.kaur\@ecodev.vic.gov.au) and [Brittney](mailto:brittney.caruana\@ecodev.vic.gov.au)) on a HiSeq3000, producing 150 bp paired-end reads. Since the library preparation and sequencing was substantially delayed, 18 DNA samples, mostly overlapping with the 20 samples sent for AgriVic, were sent for sequencing at the Australian Genome Research Facility (AGRF, Melbourne) on 4 lanes of a NextSeq500 flowcell, producing 150 bp paried-end reads (run name CAGRF19461).  
Details of the sequenced isolates is provided in (`r tbls(name="samples",display="cite")`).

```{r samples_table, eval=TRUE} 
datatable(as.data.frame(samples_table), caption=tbls("samples")) %>% # , 
          # options = list(dom = 'tf', pageLength = 40)) %>%
  formatStyle('Pathogenicity',
  backgroundColor = styleInterval(0:3, c('limegreen','gold', 'orange', 'orangered', 'firebrick'))
)# pander , justify="left"
```

# Aims
* Identify strain-unique variants to develop detection methods
* Associate aggressiveness with specific variants

# Analysis Pipeline
## General overview:
1. Data pre-processing:
    a. Quality check
    b. Adaptor trimming
    c. Post-trim quality check
2. Mapping reads to a reference genome (keep unmapped)
3. Reads deduplication
4. Variant calling and filtration
5. Variant annotation (including assigining SSR haplotypes)
6. Variant-Pathogenicity association
7. Produce variant statistics and assessment 

## Methods
DNA-Seq data processing, mapping and variant calling were performed on the _Griffith University Gowonda HPC Cluster_ (using Torque scheduler), using [`r fontFmt("Snippy")` v4.4.0](https://github.com/tseemann/snippy), a rapid haploid variant calling and core genome alignment. The pipeline uses `r fontFmt("FreeBayes")` v1.3.1 [@garrison_haplotype-based_2012] and other tools to assign variant probability scores and call variants.  

At the current pipeline, each sequencing batch is processed separately due to slightly different file naming conventions. In future batches, the read files should be renamed following a standard naming conventions (starting from a pair of `Sample_id_FlowCell_R#.fastq.gz` file), which will make it much easier to process all batches with the same script, using parameters to specify batch name, read length, sequencing platform and other potential variables. Detailed methods, including code for running each of the analyses steps are provided in the associated [A_rabiei_WGS_analysis GitHub repository](https://github.com/IdoBar/A_rabiei_WGS_analysis).

### Data pre-processing
Install needed software in a `conda` environment on Gowonda2.
```{bash setup_tools}
# install snippy (need to fix internet connection to gowonda2 - use patched netcheck in ~/bin)
~/bin/netcheck
conda install -n snippy -c conda-forge -c bioconda snippy sra-tools bcbio-gff libgd xorg-libxpm libpng  libjpeg-turbo jpeg libtiff 
# Clean extra space
conda clean -y --all
cpanm git://github.com/IdoBar/XML-DOM-XPath-0.14@patch1
cpanm --force Bio::SeqIO
# Install pdfx to parse the report and download the files, see https://stackoverflow.com/a/33173484
easy_install -U pdfx
```


```{bash prep_genome}
# convert gff3 (from AUGUSTUS) and fasta files to genbank format
GENOME="$HOME/scratch/data/reference_genomes/Ascochyta_reference_genomes/Arab_me14"
cd $HOME/scratch/data/reference_genomes/Ascochyta_reference_genomes/
# download conversion script
wget https://raw.githubusercontent.com/chapmanb/bcbb/master/gff/Scripts/gff/gff_to_genbank.py
python gff_to_genbank.py $GENOME.gff3 $GENOME.fasta
```

#### Adaptor Trimming
Adaptors needed to be removed, as well as very low quality bases/reads, so trimming was performed with BBduk (from BBMap v38.34). See official download page on [SourceForge](https://sourceforge.net/projects/bbmap/), [user guide](http://jgi.doe.gov/data-and-tools/bbtools/bb-tools-user-guide/bbduk-guide/) and [SEQanswers thread](http://seqanswers.com/forums/showthread.php?t=42776).  
Raw files quality after adaptor trimming was assessed with `r fontFmt("FastQC")` v0.11.8.

### Mapping to the reference genome and calling variants (using Snippy)
The trimmed reads were mapped to the _A. rabiei_ reference genome, strain Me14 ([GCA_004011695.1](https://www.ncbi.nlm.nih.gov/assembly/GCA_004011695.1)) using `r fontFmt("Snippy")` v4.4.0. [Snippy](https://github.com/tseemann/snippy) is a wrapper that makes use of popular bioinformatics tools, such as `r fontFmt("bwa-mem")` v0.7.17-r1188 to map the reads to the reference genome, followed by several commands of `r fontFmt("samtools")` v1.9 to specify a Read Group for each sample (provided to Snippy with the `--rgid` flag), mark duplicates and convert the alignments into coordinate-sorted, indexed BAM files.  
The alignment files are then processed by `r fontFmt("Freebayes")` v1.3.1 to call variants from all samples and `r fontFmt("bcftools")` v1.9 and `r fontFmt("snpEff")` v4.3 to filter and annotate the variants and retain only high-quality variants (based on minimum depth and genotype quality thresholds) that are common to all samples and referred to as "core SNPs".  
Mapping statistics were obtained with `r fontFmt("Qualimap")` v.2.2.2-dev [@okonechnikov_qualimap_2016] and consolidated along with pre and post-trimming QC measures into a single, interactive report for each batch using `r fontFmt("MultiQC")` v1.7 [@ewels_multiqc:_2016]. 

```{bash snippy}
# Prepare the commands
DATE=`date +%d_%m_%Y`
# BATCH=macrogen
RUN="Snippy_${DATE}" # day of run was 02_02_2019
mkdir ${RUN}
cd !$
NCORES=12
GENOME="$HOME/scratch/data/reference_genomes/Ascochyta_reference_genomes/Arab_me14"
IGNORE_SAMS='11_S44|5B_S38|2_S34|11_S44|15CUR005|AGRF_18|AGRF_08|F15023|20_S53'
# Link all trimmed files into current folder
ls -1 ../Macrogen_sequences_1702KHP-0164/macrogen_BT2_process_03_04_2019/trimmed_* | parallel ln -s {} ./
ls -1 ../AGRF_CAGRF19461_HGMLMAFXY/AGRF_BT2_process_04_04_2019/trimmed_AGRF_* | parallel ln -s {} ./
ls -1 ../AgVic_WGS2018/AgriVic_BT2_process_05_04_2019/trimmed_* | parallel ln -s {} ./
# remove poor samples
ls -1 trimmed_* | egrep $IGNORE_SAMS | parallel my_rename -v 's/.gz/.gz.bak/' {}

TMPLOC=$( mktemp -d --tmpdir=$HOME/ ) # create a temporary folder in the current path
# Create the commands (individual file pairs first)
find ./ -maxdepth 1 -name "*_R1.fastq.gz" | sort | gawk -F"\t" -v genome=$GENOME.gb -v ncores=$NCORES -v tmpdir=$TMPLOC '{n=split($1,a,"/"); read2=gensub("_R1\\.", "_R2.", "1", $1); basename=gensub(/trimmed_(.+)_R1.fastq.gz/, "\\1", "1", a[n]) ; printf("cd $PBS_O_WORKDIR; source ~/.bashrc; conda activate snippy; snippy --cpus %s --tmpdir %s --outdir %s --report --rgid %s --ref %s --R1 %s --R2 %s \n", ncores, tmpdir, basename, basename, genome, $1, read2)}' > ${RUN}.bash

# Prepare PBS script
echo '#!/bin/bash -v
#PBS -V
#PBS -l' "select=2:ncpus=${NCORES}:mem=48GB,walltime=10:30:00

cd \$PBS_O_WORKDIR
gawk -v ARRAY_IND=\$PBS_ARRAY_INDEX 'NR==ARRAY_IND' \${CMDS_FILE} | bash" > ${RUN}.pbspro

# Run the commands 
JOB_NAME=${RUN}
JOBS_NUM=`cat ${RUN}.bash | wc -l`
SNPY_ID=$( qsub -J1-$JOBS_NUM -N ${JOB_NAME:0:11} -vCMDS_FILE=${RUN}.bash  ${RUN}.pbspro ) 
SNPY_ID=$( echo $SNPY_ID | egrep -o "[0-9]{7}"  )
# record the array ID: 5247580[] Macrogen batch on Gowonda
# find and remove empty files
find . -size 0 -exec rm {} + 
# remove tmp folder
rm -rf $TMPLOC
# Check that all jobs finished successfuly
find . -regextype posix-egrep -regex '\./.*\.e[0-9]{7}.*' | xargs grep "ExitStatus"
```

Or run them with the same sample name, but appended for each replicate (good for error estimation and visualisation)


```{bash snippy-ind-renamed}
# Prepare the commands
DATE=`date +%d_%m_%Y`
# BATCH=macrogen
RUN="Snippy_multi_${DATE}" # day of run was 02_02_2019
mkdir ${RUN}
cd !$
NCORES=12
NNODES=2
GENOME="$HOME/scratch/data/reference_genomes/Ascochyta_reference_genomes/Arab_me14"
IGNORE_SAMS='11_S44|5B_S38|2_S34|11_S44|15CUR005|AGRF_18|AGRF_08|F15023|20_S53'
# Link all trimmed files into current folder
ls -1 ../Macrogen_sequences_1702KHP-0164/macrogen_BT2_process_03_04_2019/trimmed_* | parallel ln -s {} ./
ls -1 ../AGRF_CAGRF19461_HGMLMAFXY/AGRF_BT2_process_04_04_2019/trimmed_AGRF_* | parallel ln -s {} ./
ls -1 ../AgVic_WGS2018/AgriVic_BT2_process_05_04_2019/trimmed_* | parallel ln -s {} ./
# remove poor quality samples
ls -1 trimmed_* | egrep $IGNORE_SAMS | parallel my_rename -v 's/.gz/.gz.bak/' {}

# either use 
# create input file for snippy-multi of duplicated samples and rename to isolate name
 egrep -v $IGNORE_SAMS $HOME/scratch/data/A_rabiei_WGS/A_rabiei_isolate_list_for_wgs.txt | tail -n+2 | sort -k2 | gawk  -v ORS="" 'BEGIN{isolate=""; letters="abcdefgh"}isolate!=$2{isolate=$2; printf "%s\ttrimmed_%s_R1.fastq.gz\ttrimmed_%s_R2.fastq.gz\n", isolate, $1, $1; i=0; next}isolate==$2{i+=1; printf "%s%s\ttrimmed_%s_R1.fastq.gz\ttrimmed_%s_R2.fastq.gz\n", isolate, substr(letters, i, 1), $1, $1; i=1}'  > snippy_input_samples.tab
 
# prepare commands:
# either use snippy-multi
# snippy-multi snippy_input_samples.tab --ref $GENOME.gb --cpus $(( NCORES*NNODES )) > ${RUN}.bash
# or with gawk
cat snippy_input_samples.tab | gawk -F"\t" -v genome=$GENOME.gb -v ncores=$(( NCORES* NNODES )) '{RG=$1; sub(/[a-h]$/, "", RG); printf("snippy --cpus %s --outdir %s --report --rgid %s --ref %s --R1 %s --R2 %s \n", ncores,  $1, RG, genome, $2, $3)}' > ${RUN}.bash


# Prepare PBS script
echo '#!/bin/bash 
#PBS -V
#PBS -l' "select=${NNODES}:ncpus=${NCORES}:mem=48GB,walltime=5:30:00

cd \$PBS_O_WORKDIR
source ~/.bashrc 
conda activate snippy
gawk -v ARRAY_IND=\$PBS_ARRAY_INDEX 'NR==ARRAY_IND' \${CMDS_FILE} | bash" > ${RUN}.pbspro

# Run the commands 
JOB_NAME=${RUN}
JOBS_NUM=`cat ${RUN}.bash | wc -l | gawk '{print $1}'` # head -n -1
SNPY_ID=$( qsub -J1-$JOBS_NUM -N ${JOB_NAME:0:11} -vCMDS_FILE=${RUN}.bash  ${RUN}.pbspro ) 
SNPY_ID=$( echo $SNPY_ID | egrep -o "[0-9]{7}"  )
# record the array ID: 5247580[] Macrogen batch on Gowonda

# Run snippy-core on the output files
SNPY_FOLDS=$( cut -f1,1 snippy_input_samples.tab | xargs )
SNPY_REF="'$( head -n1 snippy_input_samples.tab | cut -f1,1 )/ref.fa'"
CORE_JOB=snippy_core_"${DATE}"
# CORE_CMD=$( tail -n1 ${RUN}.bash )
SNPY_CORE_ID=$( echo "cd $( pwd ) ; source ~/.bashrc ; conda activate snippy; snippy-core --ref $SNPY_REF $SNPY_FOLDS " | qsub -V -l select=${NNODES}:ncpus=${NCORES}:mem=48GB,walltime=1:00:00  -N ${CORE_JOB:0:11} -W depend=afterok:$SNPY_ID[] ) # 5248661.pbsserver
SNPY_CORE_ID=$( echo $SNPY_CORE_ID | egrep -o "[0-9]{7}" )

# Run qualimap on bam files (files need to be sorted)
QUALIMAP_JOB="Snippy_qualimap_${DATE}"
# create a sample/file/group file
find . -name "*.bam" | gawk '{n=split($0, a, "/"); RG=a[2]; sub(/[a-h]$/, "", RG); printf "%s\t%s\t%s\n",a[2], $0, RG}' > $QUALIMAP_JOB.samples
# run Qualimap
QUALIMAP_JOB_ID=$( echo "cd $( pwd ) ; unset DISPLAY ; qualimap multi-bamqc -r -d $QUALIMAP_JOB.samples -outformat PDF:HTML -outdir $QUALIMAP_JOB -outfile $QUALIMAP_JOB.pdf" | qsub -V -l select=2:ncpus=12:mem=16GB,walltime=10:00:00 -N ${QUALIMAP_JOB:0:11} -W depend=afterok:$SNPY_CORE_ID) # 5248673.pbsserver
QUALIMAP_JOB_ID=$( echo $QUALIMAP_JOB_ID | egrep -o "[0-9]{7}" )

# multiqc report
MULTIQC_JOB="Snippy_qc_${DATE}"
echo "cd $( pwd ) ; multiqc -i $MULTIQC_JOB -o $MULTIQC_JOB ." | qsub -V -l select=1:ncpus=12:mem=8GB,walltime=3:00:00 -N ${MULTIQC_JOB:0:11} -W depend=afterok:$QUALIMAP_JOB_ID # 5248672.pbsserver


# find and remove empty files
find . -size 0 -exec rm {} + 

# Check that all jobs finished successfuly
find . -regextype posix-egrep -regex '\./.*\.e[0-9]{7}.*' | xargs grep "ExitStatus"
```

Run again, this time combining all the read files that correspond to the same sample.

```{bash snippy-multi}
# Prepare the commands
DATE=`date +%d_%m_%Y`
# BATCH=macrogen
RUN="Snippy_multi_${DATE}" # day of run was 02_02_2019
mkdir ${RUN}
cd !$
NCORES=12
NNODES=2
GENOME="$HOME/scratch/data/reference_genomes/Ascochyta_reference_genomes/Arab_me14"
IGNORE_SAMS='11_S44|5B_S38|2_S34|11_S44|15CUR005|AGRF_18|AGRF_08|F15023|20_S53'
# Link all trimmed files into current folder
ls -1 ../Macrogen_sequences_1702KHP-0164/macrogen_BT2_process_03_04_2019/trimmed_* | parallel ln -s {} ./
ls -1 ../AGRF_CAGRF19461_HGMLMAFXY/AGRF_BT2_process_04_04_2019/trimmed_AGRF_* | parallel ln -s {} ./
ls -1 ../AgVic_WGS2018/AgriVic_BT2_process_05_04_2019/trimmed_* | parallel ln -s {} ./
# remove poor quality samples
ls -1 trimmed_* | egrep $IGNORE_SAMS | parallel my_rename -v 's/.gz/.gz.bak/' {}

# merge reads
# Combine the read files from each lane (and remove barcode and flowcell information)
mkdir merged_reads
# download files for ArII from NCBI SRA
netcheck
fasterq-dump SRR1765987 -p -O ./merged_reads
# gzip the files
echo "cd $( pwd )/merged_reads ; parallel pigz -8 ::: *.fastq" | qsub -V -l select=1:ncpus=12:mem=12GB,walltime=2:00:00  -N gzip_reads

MERGE_LANES=merge_lanes_{DATE}
parallel --dryrun "eval cat {=s/L001/*/=} > {=s:.*/::; s/_HGMLMAFXY_[ACGT-]*_L001//; =}" ::: ../*L001*gz > $MERGE_LANES.cmds

# either use 
# create input file for snippy-multi of duplicated samples and rename to isolate name
 egrep -v $IGNORE_SAMS $HOME/scratch/data/A_rabiei_WGS/A_rabiei_isolate_list_for_wgs.txt | tail -n+2 | sort -k2 | gawk  -v ORS="" 'NR==1{isolate=$2; printf "cat ",$1 }isolate!=$2{ printf "> merged_reads/%s_R1.fastq.gz \n cat trimmed_%s_R1.fastq.gz ", isolate, $1; isolate=$2; next}isolate==$2{printf "trimmed_%s_R1.fastq.gz ", $1}END{printf "> merged_reads/%s_R1.fastq.gz \n", isolate}'  > merge_reads_R1.cmds
 
echo "cd $( pwd ) ; cat  merge_reads_R1.cmds | parallel " | qsub -V -l select=1:ncpus=12:mem=8GB,walltime=00:20:00  -N merge_reads1
# replace R1 with R2
echo "cd $( pwd ) ; sed 's/_R1/_R2/g'  merge_reads_R1.cmds | parallel " | qsub -V -l select=1:ncpus=12:mem=8GB,walltime=00:20:00  -N merge_reads2
 
TMPLOC=$( mktemp -d --tmpdir=$HOME/ ) # create a temporary folder in the current path 
# prepare commands:
# either use snippy-multi
# snippy-multi snippy_input_samples.tab --ref $GENOME.gb --cpus $(( NCORES*NNODES )) > ${RUN}.bash
# or with gawk
ls -1 merged_reads/*_R1.fastq.gz | gawk -F"\t" -v genome=$GENOME.gb -v tmpdir=$TMPLOC -v ncores=$(( NCORES* NNODES )) '{RG=gensub("merged_reads/(.+)_R1.fastq.gz", "\\1", 1);  printf("snippy --cpus %s --tmpdir %s --outdir %s --report --rgid %s --ref %s --R1 %s --R2 %s \n", ncores, tmpdir, RG, RG, genome, $1, gensub(/_R1/, "_R2", 1))}' > ${RUN}.bash


# Prepare PBS script
echo '#!/bin/bash 
#PBS -V
#PBS -l' "select=${NNODES}:ncpus=${NCORES}:mem=48GB,walltime=5:30:00

cd \$PBS_O_WORKDIR
source ~/.bashrc 
conda activate snippy
gawk -v ARRAY_IND=\$PBS_ARRAY_INDEX 'NR==ARRAY_IND' \${CMDS_FILE} | bash" > ${RUN}.pbspro

# Run the commands 
# JOB_NAME=${RUN}
JOBS_NUM=$( cat ${RUN}.bash | wc -l | gawk '{print $1}' ) # head -n -1
SNPY_ID=$( qsub -J1-$JOBS_NUM -N ${RUN:0:11} -vCMDS_FILE=${RUN}.bash ${RUN}.pbspro ) 
SNPY_ID=$( echo $SNPY_ID | egrep -o "[0-9]{7}"  )
# record the array ID: 5247580[] Macrogen batch on Gowonda

# Run snippy-core on the output files
SNPY_FOLDS=$( ls -1 merged_reads/*_R1.fastq.gz | gawk -vORS=" " '{RG=gensub("merged_reads/(.+)_R1.fastq.gz", "\\1", 1); print RG}' )
SNPY_REF="'$( echo $SNPY_FOLDS | cut -f1,1 -d" " )/ref.fa'"
CORE_JOB=snippy_core_"${DATE}"
# CORE_CMD=$( tail -n1 ${RUN}.bash )
SNPY_CORE_ID=$( echo "cd $( pwd ) ; source ~/.bashrc ; conda activate snippy; snippy-core --ref $SNPY_REF $SNPY_FOLDS " | qsub -V -l select=${NNODES}:ncpus=${NCORES}:mem=48GB,walltime=1:00:00  -N ${CORE_JOB:0:11} -W depend=afterok:$SNPY_ID[] ) # 5248661.pbsserver
SNPY_CORE_ID=$( echo $SNPY_CORE_ID | egrep -o "[0-9]{7}" )

# Run qualimap on bam files (files need to be sorted)
QUALIMAP_JOB="Snippy_qualimap_${DATE}"
# create a sample/file/group file
find -L . -name "*.bam" | gawk '{n=split($0, a, "/");printf "%s\t%s\n",a[2], $0}' > $QUALIMAP_JOB.samples
# run Qualimap
QUALIMAP_JOB_ID=$( echo "cd $( pwd ) ; unset DISPLAY ; qualimap multi-bamqc -r -d $QUALIMAP_JOB.samples -outformat PDF:HTML -outdir $QUALIMAP_JOB -outfile $QUALIMAP_JOB.pdf" | qsub -V -l select=2:ncpus=12:mem=16GB,walltime=10:00:00 -N ${QUALIMAP_JOB:0:11} ) # 5248673.pbsserver
QUALIMAP_JOB_ID=$( echo $QUALIMAP_JOB_ID | egrep -o "[0-9]{7}" )

# multiqc report
MULTIQC_JOB="Snippy_qc_${DATE}"
echo "cd $( pwd ) ; multiqc -i $MULTIQC_JOB -o $MULTIQC_JOB ." | qsub -V -l select=1:ncpus=12:mem=4GB,walltime=3:00:00 -N ${MULTIQC_JOB:0:11} -W depend=afterok:$QUALIMAP_JOB_ID # 5248672.pbsserver


# find and remove empty files
find . -size 0 -exec rm {} + 
# remve temp dir
rm -rf $TMPLOC
# Check that all jobs finished successfuly
find . -regextype posix-egrep -regex '\./.*\.e[0-9]{7}.*' | xargs grep "ExitStatus"
```

#### Contaminations in Macrogen samples
Both the initial QC and the mapping results show that there was a contamination in the DNA samples of at least three isolates: 16CUR019, 15CUR003, FT15023. This conclusion was obvious from the different GC content signatures of the three isolates (`r figs(name="GC_cont",display="cite")`) compared with the other isolates and from the low mapping rates of these isolates to the _A. rabiei_ reference genome (see bottom of `r tbls(name="mapping_rates",display="cite")`).  
FT15023 in particular hardly contained any reads mappable to the _A. rabiei_ reference genome (<0.1%).  
A sub-sample of the raw reads from isolate FT15023 was matched against the NCBI nucleotide collection (nt) and identified the contamination as of bacterial origin (_Ochrobactrum pituitosum/pseudogrignonense_). 

#### Contaminations in AGRF and AgriVic samples
Both the initial QC and the mapping results show that there was a contamination in the DNA samples of at least three isolates: AGRF_05 (17CUR007), AGRF_08 (TR8102) and AGRF_18 (TR9573). This conclusion was obvious from the different GC content signatures of the three isolates (`r figs(name="GC_cont",display="cite")`) compared with the other isolates and from the mapping rates of these isolates to the _A. rabiei_ reference genome (see bottom of `r tbls(name="mapping_rates",display="cite")`).   
A sub-sample of the raw reads from isolate TR9573 was matched against the NCBI nucleotide collection (nt) and identified the contamination as of bacterial origin (*Stenotrophomonas maltophilia*).  
Since similar contamination levels were found in the same samples in both the AGRF and AgriVic batches, it's likely that it had originated from our lab.  
To further investigate the origin of the contamination, the reads that didn't map to the _A. rabiei_ genome will be clustered and deduplicated using `r fontFmt("clumpify.sh")` from the `r fontFmt("BBtools")` suite, as described in this [Biostars thread](https://www.biostars.org/p/277013/). The clustered reads will be used to construct "mini-assemblies" from the contaminated samples using `r fontFmt("Tadpole")` from the `r fontFmt("BBtools")` suite.  
The assembled contigs will be BLASTed against the nr NCBI database, with species and kingdom annotation and the 20 most common organisms will be identified from each sample.

Samples with less than 20% mapping and x15 coverage were removed from the rest of the analysis (see highlighted rows in `r tbls(name="mapping_rates",display="cite")`).  

Error rates were estimated by individually processing the files from each batch and assessing the rate of mismatch variant calls within replicates of the same isolate.
_To process mapping table, copy the `multisampleBamQcReport.html` file from the server to the local analysis folder_

```{r snippy_stats, eval=TRUE, echo=FALSE}
analysis_basename <- "A_rabiei_2018"
analysis_name <- "Snippy_multi_17_07_2019"
analysis_folder <- file.path("..", analysis_name)
variant_method <- "snippy"
# analysis_folder <- "../FB_vars_01_03_2019"
# analysis_outdir <- glue("./output/{variant_method}/")
error_rates <- readxl::read_excel("output/results/pipeline_comparison.xlsx", 
                                  sheet = "Snippy_multi_07_07_2019") %>% 
  select(-vcf_file)
mean_allele_error <- mean(error_rates$allele_error_rate)
stats_table <- read_tsv(file.path(analysis_folder,"core.txt")) 


# mapping_table <- list.files(analysis_folder, ".bbmap.stats", full.names = TRUE) %>% map_df(read_tsv) %>% 
#   mutate_at(vars(contains("mapped")),  ~as.numeric(sub("%", "", ., fixed=TRUE))/100) %>%
#   mutate(Mapping_rate=rowMeans(.[,-1]), Mapping_tool = "BBmap (v38.22)", 
#          Sample_id=str_extract(.$sample_id, paste(sequencing_table$Submission_id, collapse = "|"))) %>%
#   group_by(Sample_id, Mapping_tool) %>%
#   summarise(Mapping_rate=mean(Mapping_rate)) %>% ungroup() %>% 
#   left_join(sequencing_table,by=c("Sample_id"="Submission_id")) %>%
# # mutate( Isolate=sequencing_dict[sample_id]) %>% 
#   dplyr::select(Isolate, Mapping_rate, Mapping_tool, Sample_id, Sequencing_Centre) 

# Load qualimap statistics (copy summary html files to raw_data folder)

qualimap_files <- list.files(analysis_folder, "multisampleBamQcReport.html", 
                             full.names = TRUE, 
                             recursive = TRUE)
exclude_columns <- c("Coverage std", "Insert size median")
  # mutate(`Pathog. Group`=samples_table$Pathogenicity[match(samples_table$Isolate, .$Isolate)] ) 
qualimap_results <-  qualimap_files[1] %>% map_df(~htmltab(., which = "//td/b[text() = 'Sample name']/ancestor::table")) %>% 
  rename(Isolate=`Sample name`, Coverage=`Coverage mean`) %>% 
  dplyr::select(-one_of(exclude_columns)) %>% 
  mutate_at(.vars = vars(-starts_with("Isolate")), .funs = as.numeric) %>%
  left_join(., error_rates %>% select(Isolate=replicate_group, Error_rate=allele_error_rate,
                                       Replicates=replicate_num)) %>%
  arrange(Isolate, desc(Coverage)) %>% set_names(., gsub(" ", "_", colnames(.))) %>%
  # dplyr::select(Isolate, GC_percentage, Mapping_quality_mean, Mapping_rate, Coverage, Mapping_tool, Sample_id, Sequencing_Centre) %>%
  write_csv(filedate(glue::glue("{analysis_basename}_{analysis_name}.mapping.stats"), ".txt", "./output/results", dateformat = FALSE))

# Summarise mapping results
# mapping_summary <- qualimap_results %>% filter(Coverage>20) %>% 
#   group_by(Sequencing_Centre) %>% 
#   summarise(Coverage=sprintf("x%.2f",mean(Coverage)), 
#             Mapping_rate=sprintf("%.2f%%", mean(Mapping_rate, na.rm=TRUE)*100),
#                                      Mapping_qual=round(mean(Mapping_quality_mean), 2),
#             Files=n()) %>%
#   # mutate(Reads_per_file=format(c(2224642.64, 36500108.00), 
#   #                              digits = 2, scientific = TRUE)) %>%
#   arrange(desc(Sequencing_Centre)) %>% 
#   write_csv(filedate(glue::glue("{analysis_basename}_AGRF_Macro_AgVic.mapping.sum"), ".txt", "./output/results", dateformat = FALSE))

```

```{r map_stats, eval=TRUE}
datatable(as.data.frame(qualimap_results), # %>% mutate_if(is.numeric, ~round(., 2))),
          caption=tbls("mapping_rates")) %>% #, 
  formatRound(~Coverage+GC_percentage+Mapping_quality_mean) %>% 
  formatPercentage('Error_rate', 2) %>% 
          # options = list(dom = 'tf', pageLength = 40)) %>%
  formatStyle("Coverage", target = "row",
  backgroundColor = styleInterval(c(10,20), c('#ef3125', '#feed95', NA))
)

# pander(as.data.frame(qualimap_results), caption=tbls("mapping_rates"), justify="left")

# datatable(as.data.frame(mapping_stats), caption = tbls("mapping_rates"), # , width=10
#           style="default", rownames = FALSE, autoHideNavigation=TRUE) %>% 
#   formatPercentage('Mapping_rate', 2) %>% #formatStyle('Isolate',
#   formatStyle('Mapping_rate',
#     color = styleInterval(c(0.05, 0.5), c('yellow', 'blue', 'black')),
#     backgroundColor = styleInterval(c(0.05, 0.5), c('red', 'yellow',NA))
#   )
```



```{r QC_GC, eval=FALSE, echo=FALSE, out.width='100%', fig.cap=figs("GC_cont")}
include_graphics("plots/fastqc_per_sequence_gc_content_plot.png")
```



### Variant Annotation
Variants were then further filtered to keep only polymorphic and bi-allelic SNPs using the `r fontFmt("VariantAnnotation")` v`r packageVersion("VariantAnnotation")` and `r fontFmt("GenomicRanges")` v`r packageVersion("GenomicRanges")` R Bioconductor packages [@obenchain_variantannotation:_2014; @lawrence_software_2013]. The SNPs were annotated and position of each variant relative to gene locations was determined (coding/intron/promotor/intergenic), based on the reference genome and gene models of _A. rabiei_ strain _Me14_ (where the contig names were shortened to remove the `Arab_Me14` prefix). 

```{bash fix_contig_names}
cat A.rabiei_me14.fasta | sed 's/Arab_Me14_//' > A_rabiei_me14_short_names.fasta
zcat Arab_me14.gff3.gz | sed 's/Arab_Me14_//' > Arab_me14_short_names.gff
```

Variants in coding regions of genes were identified as Synonymous/Non-synonymous/Non-sense mutations if they were silent, changing the amino acid or the reading frame, respectively. Additional annotation of the genes at each SNP site was performed by a BLASTp search against the NCBI non-redundant protein database (nr) and scanning against the InterPro conglomerate dbs. Effector prediction of the variant-associated genes was performed by `r fontFmt("EffectorP")` v1.0/2.0 [@SperschneiderEffectorPpredictingfungal2016;@JanaImprovedpredictionfungal2018]. The variants were summarised and visualised across the genome scaffolds and visualised using `r fontFmt("circlize")` v`r packageVersion("circlize")` R package [@gu_circlize_2014].

```{bash interproscan}
# Download the python wrapper

$HPC_GRID_RUNNER_DIR/BioIfx/hpc_FASTA_GridRunner.pl --cmd_template "cd $PBS_O_WORKDIR; pyenv shell miniconda3-latest; ~/etc/tools/Annotation/InterPro/iprscan5_urllib3.py --sequence=__QUERY_FILE__ --outfile=__QUERY_FILE__.interpro.tsv --outformat=tsv --goterms --pathways --email=i.bar@griffith.edu.au " --query_fasta Assoc_SNP_genes_cds_05_02_2018.fasta -G $HPC_GRID_RUNNER_DIR/hpc_conf/small_PBS_jobs.conf -N 1 -O SNP_interpro
```

Look for particular effector genes and genes associated with plant-pathogen interactions and pathogenicity genes. Look in the literature and create a list of target genes.

### Variant-Pathogenicity association
Association between variants and pathogenicity levels was identified by `r fontFmt("SNPassoc")` v`r packageVersion("SNPassoc")` R package [@gonzalez_snpassoc:_2007], using a codominant gene model and a significance threshold of _p_-value $\le0.005$.  



## Alternative analyses

## Appendix 1. Additional analyses (not used)
#### Genotype Imputation
The resulting SNPs were used as a basis for imputation to try and infer missing genotypes by assessing linkage between markers and fixed haplotypes.  
Several methods were tested:
1. Imputation was performed with `r fontFmt("LinkImpute", custom_font)` [@money_linkimpute:_2015], using a KNNi algorithm, as implemented in `r fontFmt("TASSEL", custom_font)` v5.2.40 [@glaubitz_tassel-gbs:_2014]. 
2. With `r fontFmt("LinkImputeR", custom_font)` v1.1.1 [@money_linkimputer:_2017], using an improved KNNi algorithm.  

```{bash vcf_linkimputer}
# Genotype imputation with LinkImputeR
alias LinkImputeR='java -jar /c/Bioinformatics/Tools/linkimputer/LinkImputeR.jar'
# edit `accuracy.ini` and modify input file name and other parameters:
[Input]
filename = ../A_rabiei_on_me14_DP_GQ_corr.bt2.fb.snps.vcf
save = A_rabiei_on_me14_DP_GQ_corr.bt2.fb.snps.filtered.vcf
maxdepth = 200

[InputFilters]
maf=0.001
positionmissing = 0.6
hw=0.05

[Global]
depth = 5

[CaseFilters]
missing = 0.6,0.7,0.8,0.9
maf=0.001, 0.01,0.05,0.1,0.15,0.2

[Accuracy]
numbermasked = 5000
# Create a folder for the statistics
mkdir Linkimputer_stats
# Run LinkImputeR to assess accuracy (doesn't seem to be working on Windows)
LinkImputeR -s accuracy.ini
# Impute genotypes
LinkImputeR Linkimpute2.xml 'Case 10' gstacks_case4.imputed.vcf # Miss=0.7, MAF=0.05, Samples=20, Markers=1134
LinkImputeR Linkimpute2.xml 'Case 18' gstacks_case18.imputed.vcf # Miss=0.4, MAF=0.2, Samples=130, Markers=11422

# Fix error in field annotation
sed -i.bak 's/ID=UG/ID=OG/g' gstacks_case18.imputed.vcf
sed -i.bak 's/ID=UG/ID=OG/g' gstacks_case4.imputed.vcf

```

After filtration, the `.vcf` file was converted to `r fontFmt("PLINK")`'s `.tped` format. In order to export to `r fontFmt("PLINK")` format, a `.tfam` file was created, which contains a table like `r tbls(name="tfam",display="cite")` (without the header line).
```{r tfam_table, eval=TRUE} 
pander(as.data.frame(head(tfam_table)), caption=tbls("tfam"), justify="left")
```

## Appendix 2. Useful resources

* Whole-Genome Comparison of _Aspergillus fumigatus_ Strains Serially Isolated from Patients with Aspergillosis. [@hagiwara_whole-genome_2014]:

> **Sequence analysis:** The Illumina data sets were trimmed using fastq-mcf in ea-utils (version 1.1.2-484), i.e., sequencing adapters and sequences with low quality scores (Phred score [Q], <30) were removed (24). The data sets were mapped to the genome sequence of the _A. fumigatus_ genome reference strain Af293 (29,420,142 bp, genome version s03-m04-r03) (25, 26) using Bowtie 2 (version 2.0.0-beta7) with the very sensitive option in end-to-end mode (27). Duplicated reads were removed using Picard (version 1.112) (<http://picard.sourceforge.net>). The programs mpileup and bcftools from SAMtools (version 0.1.19-44428cd) were used to perform further quality controls. In mpileup, the -q20 argument was used to trim reads with low-quality mapping, whereas the argument -q30 was used to trim low-quality bases at the 3' end (28). The bcftools setting was set to -c in order to call variants using Bayesian inference. Consensus and single nucleotide polymorphisms (SNPs) were excluded if they did not meet a minimum coverage of 5x or if the variant was present in <90% of the base calls (29, 30). The genotype field in the variant call format (VCF) files indicates homozygote and heterozygote probabilities as Phred-scaled likelihoods. SNPs were excluded if they were called as heterozygous genotypes using SAMtools. The mapping results were visualized in the Integrative Genomics Viewer (version 2.3.3) (31, 32). The reference genome data included information on open reading frames and annotations, from which the SNPs were designated non-synonymous or synonymous.  
Single nucleotide mutations were confirmed by Sanger sequencing. Regions of approximately 400 bp that contained a mutation were amplified with appropriately designed primer pairs and then sequenced. The primer sequences are listed in Table S1 in the supplemental material, which were named as follows. For verification of the SNPs in strains from patient I or patient II, PaI or PaII was added to the primer name, respectively. For non-synonymous SNPs, synonymous SNPs, or SNPs in a non-coding region, (NS, Syno, NonC) was added to the primer name, respectively.  
**Analysis of unmapped reads:** _De novo_ assembly of the unmapped reads was conducted using the Newbler assembler 2.9 (Roche), with default parameters. The contigs were selected based on size/depth criteria: those of <500 bp and/or with a depth of <30x coverage were removed. To investigate whether unique genome sequences were present in strains isolated from the same patient, the unmapped reads of each strain were mapped to the contigs generated from all the strains in the same patient by the Bowtie 2 software. The coverage of the mapped regions was then evaluated. Gene predictions were performed using the gene prediction tool AUGUSTUS (version 2.5.5), with a training set of  _A. fumigatus_ (33). The parameters of AUGUSTUS were -species = aspergillus_fumigatus, -strand = both, -genemodel = partial, -singlestrand = false, -protein = on, -introns = on, -start = on, -stop = on, -cds = on, and -gff3 = on. To compare all the predicted genes with _Aspergillus_ genes, consisting of 244,811 genes available on AspGD (34), a reciprocal BLAST best hit approach was performed by BLASTp (35), with an E value of 1.0e<sup>-4</sup>. All BLASTp results were filtered based on a BLASTp identity of $\ge 80$% and an aligned length coverage of $\ge 80$%.

## General information
This document was last updated at `r Sys.time()` using R Markdown (built with `r R.version.string`). Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. It is especially powerful at authoring documents and reports which include code and can execute code and use the results in the output. For more details on using R Markdown see <http://rmarkdown.rstudio.com> and [Rmarkdown cheatsheet](https://www.rstudio.com/wp-content/uploads/2016/03/rmarkdown-cheatsheet-2.0.pdf).

***
## Bibliography

<!-- ```{r results='asis', eval=TRUE} -->
<!-- PrintBibliography(biblio) -->
<!-- ``` -->

